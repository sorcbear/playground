<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Color Puzzle Grid</title>

<style>
  :root{
    --maxw: 980px;

    --fs-body: 18px;
    --lh-body: 1.7;

    --c-text:#111;
    --c-border:#000;
    --bg:#fff;

    --outerLine:4px;   /* 黑框粗细 */
    --radius:0px;      /* 你之前统一是直角 */

    --gap: 24px;       /* 田字格之间的间距：你想更紧就改小；想无缝就设 0 */
    --tileMax: 440px;  /* 每格最大显示宽度（会自适应缩小） */

    --pal-h: 44px;
    --pal-gap: 10px;
    --pal-pad: 14px;

    --swatch: 26px;
    --swatch-border: 2px;
  }

  *{ box-sizing:border-box; }

  html,body{
    margin:0;
    background:var(--bg);
    color:var(--c-text);
    font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,
                "PingFang SC","Microsoft YaHei",Arial,sans-serif;
    font-size:var(--fs-body);
    line-height:var(--lh-body);
    -webkit-text-size-adjust: 100%;
  }

  /* iOS：禁用自动识别电话/地址样式 */
  a, a:visited{ color:inherit; text-decoration:none; }
  *{
    -webkit-tap-highlight-color: transparent;
  }

  .wrap{
    max-width: var(--maxw);
    margin: 0 auto;
    padding: 22px 16px 40px;
  }

  .title{
    margin: 0 0 18px 0;
    font-weight: 700;
    font-size: 18px;
    line-height: 1.7;
  }

  /* 田字格容器 */
  .grid{
    display:grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: var(--gap);
    align-items:start;
  }

  /* 单格 */
  .tile{
    width: 100%;
    max-width: var(--tileMax);
    justify-self: center;
  }

  /* 黑框：注意这里“无内边距”，canvas 会贴边 */
  .frame{
    border: var(--outerLine) solid var(--c-border);
    border-radius: var(--radius);
    background:#fff;
    overflow:hidden; /* 保证不出现缝/溢出 */
  }

  /* canvas 贴边显示 */
  canvas.paint{
    display:block;
    width:100%;
    aspect-ratio: 1 / 1; /* 你都是正方形，强制 1:1 */
    height:auto;
    touch-action: none;  /* 关键：手机涂抹不跟随页面滚动 */
    user-select:none;
  }

  /* 调色盘：在黑框下方，与 tile 分离，不影响黑框贴边 */
  .palette{
    display:flex;
    align-items:center;
    justify-content:center;
    gap: var(--pal-gap);
    padding: var(--pal-pad) 0 0;
  }

  .swatch{
    width: var(--swatch);
    height: var(--swatch);
    border: var(--swatch-border) solid var(--c-border);
    border-radius: 0;
    background: #fff;
    cursor:pointer;
    position:relative;
  }

  /* 选中反馈：白色外框（你之前要求的那种） */
  .swatch.selected::after{
    content:"";
    position:absolute;
    inset: -6px;
    border: 2px solid #fff;
    outline: 2px solid #000;
    pointer-events:none;
  }

  /* 小屏优化 */
  @media (max-width: 720px){
    :root{
      --gap: 16px;
      --tileMax: 9999px;
    }
    .grid{
      grid-template-columns: 1fr; /* 手机竖屏改成一列更稳（你若坚持两列，把这行删掉） */
    }
  }

  /* 你如果手机也要两列，删掉上面 @media 里 grid-template-columns 那一行即可 */
</style>
</head>

<body>
  <div class="wrap">
    <p class="title">
      请继续往天平路康平路路口方向前进，在到达路口之前，你要仔细留意马路两边的街景。你会先后在街面上看到以下4个图案。请选择正确的颜色涂抹每个图缺失色彩的区域，找到正确的线索。
    </p>

    <div class="grid" id="grid"></div>
  </div>

<script>
(() => {
  /* =========================
     1) 配置：改成你的文件名
     ========================= */
  const TILES = [
    { id:"skull", img:"bw1_1280.jpg", mask:"skull_mask.png" },
    { id:"avec",  img:"avec.jpg",      mask:"avec_mask.png"  },
    { id:"lion",  img:"lion.jpg",      mask:"lion_mask.png"  },
    { id:"violin",img:"violin.jpg",    mask:"violin_mask.png"},
  ];

  /* 你的调色盘（可按需调整） */
  const PALETTE = [
    { name:"black",  color:"#000000" },
    { name:"white",  color:"#ffffff" },
    { name:"red",    color:"#d32f2f" },
    { name:"blue",   color:"#1976d2" },
    { name:"green",  color:"#2e7d32" },
    { name:"yellow", color:"#f9a825" },
    { name:"orange", color:"#ef6c00" },
    { name:"purple", color:"#6a1b9a" },
  ];

  /* 画笔参数 */
  const BRUSH_R = 18;          // 半径
  const BRUSH_SOFT = 0.55;     // 软边比例（0~1）
  const STORAGE_PREFIX = "paint_tile_v1_";

  const grid = document.getElementById("grid");

  /* =========================
     2) 工具
     ========================= */
  function loadImage(src){
    return new Promise((resolve, reject) => {
      const im = new Image();
      im.decoding = "async";
      im.onload = () => resolve(im);
      im.onerror = reject;
      im.src = src + (src.includes("?") ? "" : `?v=${Date.now()}`); // 防缓存：你上线后可删除
    });
  }

  function makeEl(tag, cls){
    const el = document.createElement(tag);
    if (cls) el.className = cls;
    return el;
  }

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

  /* canvas 坐标换算：把 pointer 坐标换算到 canvas 像素坐标 */
  function getCanvasXY(canvas, clientX, clientY){
    const r = canvas.getBoundingClientRect();
    const x = (clientX - r.left) * (canvas.width  / r.width);
    const y = (clientY - r.top ) * (canvas.height / r.height);
    return { x, y };
  }

  /* =========================
     3) Tile 渲染：关键点
        - canvas.width/height = 底图像素尺寸（例如 1280）
        - 底图与 mask 采用同一套“cover 变换”绘制到 canvas
        - 用户涂色画到一张 layer，再用 mask alpha 裁掉（destination-in）
     ========================= */
  function drawImageCover(ctx, img, W, H){
    // cover：保证铺满，不变形，必要时裁剪边缘
    const iw = img.naturalWidth, ih = img.naturalHeight;
    const s = Math.max(W / iw, H / ih);
    const dw = iw * s, dh = ih * s;
    const dx = (W - dw) / 2;
    const dy = (H - dh) / 2;
    ctx.drawImage(img, dx, dy, dw, dh);
  }

  function buildTileDom(tile){
    const wrap = makeEl("div", "tile");

    const frame = makeEl("div", "frame");
    const canvas = makeEl("canvas", "paint");
    frame.appendChild(canvas);

    const pal = makeEl("div", "palette");

    wrap.appendChild(frame);
    wrap.appendChild(pal);

    grid.appendChild(wrap);

    return { wrap, frame, canvas, pal };
  }

  function buildPalette(palEl, onPick){
    palEl.innerHTML = "";
    let selectedIdx = 0;

    const swatches = PALETTE.map((p, idx) => {
      const b = makeEl("button", "swatch");
      b.type = "button";
      b.style.background = p.color;
      b.setAttribute("aria-label", p.name);
      if (idx === 0) b.classList.add("selected");
      b.onclick = () => {
        selectedIdx = idx;
        swatches.forEach(s => s.classList.remove("selected"));
        b.classList.add("selected");
        onPick(PALETTE[selectedIdx].color);
      };
      palEl.appendChild(b);
      return b;
    });

    onPick(PALETTE[selectedIdx].color);
  }

  function restoreLayerToCanvas(layerCanvas, dstCtx){
    dstCtx.clearRect(0,0, layerCanvas.width, layerCanvas.height);
    dstCtx.drawImage(layerCanvas, 0, 0);
  }

  function saveLayerPNG(tileId, layerCanvas){
    try{
      const key = STORAGE_PREFIX + tileId;
      const data = layerCanvas.toDataURL("image/png");
      localStorage.setItem(key, data);
    }catch(e){}
  }

  async function loadLayerPNG(tileId){
    const key = STORAGE_PREFIX + tileId;
    const data = localStorage.getItem(key);
    if(!data) return null;
    return await loadImage(data);
  }

  async function initTile(tile){
    const { canvas, pal } = buildTileDom(tile);

    // 先加载底图+mask
    const [img, mask] = await Promise.all([
      loadImage(tile.img),
      loadImage(tile.mask),
    ]);

    // 画布像素大小：直接等于底图像素（关键）
    const W = img.naturalWidth;
    const H = img.naturalHeight;
    canvas.width = W;
    canvas.height = H;

    const ctx = canvas.getContext("2d", { alpha:true });

    // 背景层：底图（固定不变）
    const bgCanvas = document.createElement("canvas");
    bgCanvas.width = W; bgCanvas.height = H;
    const bg = bgCanvas.getContext("2d");

    bg.clearRect(0,0,W,H);
    drawImageCover(bg, img, W, H);

    // mask alpha 层（固定不变）
    const maskCanvas = document.createElement("canvas");
    maskCanvas.width = W; maskCanvas.height = H;
    const mctx = maskCanvas.getContext("2d");
    mctx.clearRect(0,0,W,H);
    drawImageCover(mctx, mask, W, H);

    // 用户涂色层（可变）
    const layerCanvas = document.createElement("canvas");
    layerCanvas.width = W; layerCanvas.height = H;
    const lctx = layerCanvas.getContext("2d");

    // 如果有存档，恢复到 layer
    const saved = await loadLayerPNG(tile.id);
    if(saved){
      lctx.clearRect(0,0,W,H);
      drawImageCover(lctx, saved, W, H);
      // 再用 mask 裁一遍，避免旧版本脏边
      lctx.globalCompositeOperation = "destination-in";
      lctx.drawImage(maskCanvas, 0, 0);
      lctx.globalCompositeOperation = "source-over";
    }

    // 当前颜色
    let curColor = "#000";
    buildPalette(pal, (c) => curColor = c);

    // 刷新显示：bg + layer（layer 已被 mask 限制）
    function render(){
      ctx.clearRect(0,0,W,H);
      ctx.drawImage(bgCanvas, 0, 0);
      ctx.drawImage(layerCanvas, 0, 0);
    }
    render();

    // 画软边圆刷
    function stampBrush(x, y){
      const r = BRUSH_R;
      const inner = r * (1 - clamp(BRUSH_SOFT, 0, 0.95));
      const g = lctx.createRadialGradient(x, y, inner, x, y, r);
      g.addColorStop(0, curColor);
      g.addColorStop(1, "rgba(0,0,0,0)");

      lctx.save();
      lctx.globalCompositeOperation = "source-over";
      lctx.fillStyle = g;
      lctx.beginPath();
      lctx.arc(x, y, r, 0, Math.PI * 2);
      lctx.fill();
      lctx.restore();

      // 用 mask 限制可涂区域（关键：每次都裁，保证永不出界）
      lctx.save();
      lctx.globalCompositeOperation = "destination-in";
      lctx.drawImage(maskCanvas, 0, 0);
      lctx.restore();
    }

    // 事件：pointer
    let drawing = false;
    let last = null;
    let raf = 0;

    function scheduleRender(){
      if(raf) return;
      raf = requestAnimationFrame(() => {
        raf = 0;
        render();
      });
    }

    function onDown(e){
      e.preventDefault();
      canvas.setPointerCapture?.(e.pointerId);
      drawing = true;

      const p = getCanvasXY(canvas, e.clientX, e.clientY);
      last = p;

      stampBrush(p.x, p.y);
      scheduleRender();
    }

    function onMove(e){
      if(!drawing) return;
      e.preventDefault();

      const p = getCanvasXY(canvas, e.clientX, e.clientY);
      if(!last){
        last = p;
        stampBrush(p.x, p.y);
        scheduleRender();
        return;
      }

      // 插值：保证涂抹顺滑
      const dx = p.x - last.x;
      const dy = p.y - last.y;
      const dist = Math.hypot(dx, dy);
      const step = Math.max(4, BRUSH_R * 0.35);
      const n = Math.max(1, Math.floor(dist / step));

      for(let i=1;i<=n;i++){
        const t = i / n;
        stampBrush(last.x + dx*t, last.y + dy*t);
      }

      last = p;
      scheduleRender();
    }

    function onUp(e){
      if(!drawing) return;
      e.preventDefault();
      drawing = false;
      last = null;
      saveLayerPNG(tile.id, layerCanvas);
    }

    canvas.addEventListener("pointerdown", onDown, { passive:false });
    canvas.addEventListener("pointermove", onMove, { passive:false });
    canvas.addEventListener("pointerup", onUp, { passive:false });
    canvas.addEventListener("pointercancel", onUp, { passive:false });
    canvas.addEventListener("pointerleave", onUp, { passive:false });
  }

  (async function init(){
    // 串行初始化，避免低端机同时解码卡顿
    for(const t of TILES){
      try{
        await initTile(t);
      }catch(e){
        console.error("Failed to init tile:", t, e);
      }
    }
  })();
})();
</script>
</body>
</html>
