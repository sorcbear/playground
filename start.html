<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>Start Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --maxw: 720px;

      --fs-body: 18px;
      --lh-body: 1.6;

      --fs-hint: 18px;
      --lh-hint: 1.6;

      --ctl-h: 48px;
      --w-mainbtn: 240px;

      --gap: 18px;
      --space-action: 64px;

      --c-text:#111;
      --c-border:#000;
      --c-danger:#b00020;
      --c-muted:#888;

      /* 标题单行高度（用于固定相对位置） */
      --hint-line-h: calc(var(--fs-hint) * var(--lh-hint));

      /* 提示文字与倒计时间距（单位：标题行） */
      --hint-gap-lines: 3;
      --hint-gap: calc(var(--hint-line-h) * var(--hint-gap-lines));
    }

    html,body{
      margin:0;
      width:100%;
      height:100%;
      background:#fff;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      font-size:var(--fs-body);
      line-height:var(--lh-body);
      color:var(--c-text);
      overflow:hidden; /* ✅ 防止抖动时出现滚动条 */
    }
    button{ font-family:inherit; }

    .container{
      width:100%;
      height:100%;
      position:relative;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;   /* ✅ 上下居中 */
      padding:18px;
      box-sizing:border-box;
      text-align:center;
      overflow:hidden;
    }

    /* 倒计时阶段的文字层 */
    .centerStack{
      display:none;
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
    }

    /* ===== 通用标题样式 ===== */
    .title{
      font-size: var(--fs-hint);
      line-height: var(--lh-hint);
      font-weight: 700;
      text-align: center;
      white-space: pre-wrap;
      margin:0;
      width:min(var(--maxw),92vw);
    }

    .title-danger{
      color: var(--c-danger);
    }

    /* 倒计时固定在正中 */
    .statusFixed{
      position:absolute;
      left:50%;
      top:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
    }

    /* 提示文字固定在倒计时上方 */
    .hintFixed{
      position:absolute;
      left:50%;
      top:calc(50% - var(--hint-gap));
      transform:translateX(-50%);
      display:none;
      pointer-events:none;
    }

    /* ===== 开始按钮区域 ===== */
    .btnRow{
      width:100%;
      display:flex;
      flex-direction:column;
      align-items:center;       /* ✅ 左右居中 */
    }

    button{
      width:var(--w-mainbtn);
      height:var(--ctl-h);
      padding:0 18px;
      box-sizing:border-box;
      font-size:var(--fs-body);
      font-weight:600;
      background:#fff;
      color:#000;
      border:2px solid var(--c-border);
      cursor:pointer;
      border-radius:0;
    }
    button:hover{ background:#000; color:#fff; }
    button:disabled{ opacity:.45; cursor:default; }

    /* ===== 按钮下方提示文字 ===== */
    .btnHint{
      margin-top: calc(var(--lh-body) * 1em);
      font-size: 13px;
      color: var(--c-muted);
      text-align: center;
      user-select:none;
    }

    @media (max-width: 420px){
      :root{
        --w-mainbtn: 220px;
        --ctl-h: 46px;
        --fs-hint: 17px;
      }
    }

    /* =========================
       ✅ 爆炸覆盖层（闪烁 → 黑屏）
       ========================= */

    /* 闪烁画布 */
    #fx{
      position:fixed;
      inset:0;
      width:100vw;
      height:100vh;
      pointer-events:none;
      z-index:9999;
      opacity:0;
    }

    /* 结尾黑屏 */
    #black{
      position:fixed;
      inset:0;
      background:#000;
      opacity:0;
      pointer-events:none;
      z-index:10000;
    }

    /* 抖动 */
    @keyframes shake {
      0%{ transform:translate(0,0); }
      15%{ transform:translate(-9px,7px); }
      30%{ transform:translate(8px,-7px); }
      45%{ transform:translate(-7px,-9px); }
      60%{ transform:translate(7px,9px); }
      75%{ transform:translate(-5px,7px); }
      90%{ transform:translate(5px,-7px); }
      100%{ transform:translate(0,0); }
    }
    .shake{ animation:shake 0.55s ease-in-out; }
  </style>
</head>

<body>
  <div class="container">

    <div class="centerStack" id="centerStack">
      <div class="title hintFixed" id="hint">好像听到一段诡异的音乐...</div>
      <div class="title title-danger statusFixed" id="status"></div>
    </div>

    <div class="btnRow" id="btnRow">
      <button id="startBtn">开始游戏</button>
      <div class="btnHint">请打开手机声音后，再点击开始</div>
    </div>

  </div>

  <!-- ✅ 爆炸覆盖层 -->
  <canvas id="fx"></canvas>
  <div id="black"></div>

<script>
(() => {
  const NEXT_URL = "/playground/save/";
  const COUNTDOWN_SEC = 10;

  const NOTE_GAP_SEC = 0.25;
  const NOTE_DUR_SEC = 0.22;

  // ✅ 全局音量（你要更大声：调这里）
  // 建议 1.35~1.8 之间；太大会削波失真，已加压缩器做保护
  const MASTER_VOL = 1.55;

  const KEYS = [
    {c:"green",n:"so",m:55},{c:"green",n:"la",m:57},{c:"green",n:"si",m:59},
    {c:"red",n:"do",m:60},{c:"red",n:"re",m:62},{c:"red",n:"mi",m:64},
    {c:"red",n:"fa",m:65},{c:"red",n:"so",m:67},{c:"red",n:"la",m:69},{c:"red",n:"si",m:71},
    {c:"blue",n:"do",m:72},{c:"blue",n:"re",m:74},{c:"blue",n:"mi",m:76},
    {c:"blue",n:"fa",m:77},{c:"blue",n:"so",m:79},{c:"blue",n:"la",m:81},
  ];

  const target = [
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
    ["red","do"],["red","re"],["red","la"],["blue","re"],["blue","fa"],["red","la"],["blue","re"],["blue","fa"],
    ["green","si"],["red","re"],["red","so"],["blue","re"],["blue","fa"],["red","so"],["blue","re"],["blue","fa"],
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
  ];

  const melody = target
    .map(([c,n]) => KEYS.find(k => k.c===c && k.n===n)?.m)
    .filter(Boolean);

  const centerStack = document.getElementById("centerStack");
  const hintEl = document.getElementById("hint");
  const statusEl = document.getElementById("status");
  const btnRow = document.getElementById("btnRow");
  const startBtn = document.getElementById("startBtn");

  // ✅ 覆盖层元素
  const fx = document.getElementById("fx");
  const black = document.getElementById("black");
  const fxCtx = fx.getContext("2d", { alpha: true });

  let audioCtx = null;
  let audioEnabled = false;
  let musicPlayed = false;
  let timers = [];
  let exploded = false;

  // ✅ 音频总线（更大声 + 压缩保护）
  let masterGain = null;
  let compressor = null;

  function ensureAudio(){
    if(!audioCtx){
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      compressor = audioCtx.createDynamicsCompressor();
      compressor.threshold.setValueAtTime(-18, audioCtx.currentTime);
      compressor.knee.setValueAtTime(18, audioCtx.currentTime);
      compressor.ratio.setValueAtTime(6, audioCtx.currentTime);
      compressor.attack.setValueAtTime(0.003, audioCtx.currentTime);
      compressor.release.setValueAtTime(0.18, audioCtx.currentTime);

      masterGain = audioCtx.createGain();
      masterGain.gain.setValueAtTime(MASTER_VOL, audioCtx.currentTime);

      // source -> masterGain -> compressor -> destination
      masterGain.connect(compressor);
      compressor.connect(audioCtx.destination);
    }
    return audioCtx;
  }

  async function enableAudio(){
    const ctx = ensureAudio();
    if(ctx.state === "suspended") await ctx.resume();
    audioEnabled = true;
  }

  function midiToFreq(m){ return 440 * Math.pow(2, (m - 69) / 12); }

  function playTone(freq, d){
    if(!audioEnabled || !audioCtx) return;
    const t = audioCtx.currentTime;

    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();

    o.type = "sine";
    o.frequency.setValueAtTime(freq, t);

    // ✅ 倒计时音乐更响：峰值从 0.3 提到 0.55（再由 MASTER_VOL 放大）
    g.gain.setValueAtTime(0.0001, t);
    g.gain.linearRampToValueAtTime(0.55, t + 0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t + d);

    o.connect(g);
    g.connect(masterGain);

    o.start(t);
    o.stop(t + d + 0.05);
  }

  function playMelody(){
    melody.forEach((m, i) => {
      setTimeout(() => {
        playTone(midiToFreq(m), NOTE_DUR_SEC);
      }, i * NOTE_GAP_SEC * 1000);
    });
  }

  function clearTimers(){
    timers.forEach(clearTimeout);
    timers = [];
  }

  /* =========================
     ✅ 0 秒“机关启动”咔嚓音效
     （短促噪声 + 轻微金属感）
     ========================= */
  function playLatch(){
    if(!audioEnabled || !audioCtx) return;
    const ctx = audioCtx;
    const t0 = ctx.currentTime;

    // 短噪声
    const dur = 0.14;
    const bufferSize = Math.floor(ctx.sampleRate * dur);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<bufferSize;i++){
      const x = i / bufferSize;
      // 更“咔嚓”：前段更硬，后段迅速衰减
      data[i] = (Math.random()*2-1) * (1 - x) * (x < 0.25 ? 1.2 : 0.65);
    }
    const src = ctx.createBufferSource();
    src.buffer = buffer;

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(1600, t0);
    bp.Q.setValueAtTime(8, t0);

    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(600, t0);

    const g = ctx.createGain();
    g.gain.setValueAtTime(0.0001, t0);
    g.gain.linearRampToValueAtTime(0.95, t0 + 0.008);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    // 叠一层很短的方波“机械卡扣”
    const o = ctx.createOscillator();
    const og = ctx.createGain();
    o.type = "square";
    o.frequency.setValueAtTime(220, t0);
    o.frequency.exponentialRampToValueAtTime(110, t0 + 0.05);
    og.gain.setValueAtTime(0.0001, t0);
    og.gain.linearRampToValueAtTime(0.45, t0 + 0.006);
    og.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.08);

    src.connect(hp);
    hp.connect(bp);
    bp.connect(g);
    g.connect(masterGain);

    o.connect(og);
    og.connect(masterGain);

    src.start(t0);
    src.stop(t0 + dur);

    o.start(t0);
    o.stop(t0 + 0.09);
  }

  /* =========================
     ✅ 爆炸音效（合成）- 更响
     ========================= */
  function playExplosion(){
    if(!audioEnabled || !audioCtx) return;
    const ctx = audioCtx;

    const duration = 0.85;
    const bufferSize = Math.floor(ctx.sampleRate * duration);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);

    for(let i=0;i<bufferSize;i++){
      const x = i / bufferSize;

      // 噪声 + 低频冲击
      const noise = (Math.random()*2-1);
      const thump = Math.sin(2*Math.PI*52*x) * (1-x);

      // 初段更猛
      const punch = (x < 0.12) ? 1.25 : 0.95;

      data[i] = (noise*0.95 + thump*0.45) * (1 - x) * punch;
    }

    const src = ctx.createBufferSource();
    src.buffer = buffer;

    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(260, ctx.currentTime);
    lp.frequency.exponentialRampToValueAtTime(55, ctx.currentTime + duration);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(1.0, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

    src.connect(lp);
    lp.connect(gain);
    gain.connect(masterGain);

    src.start();
  }

  /* =========================
     ✅ 闪烁蔓延视觉（无网格）
     中心橘 → 外圈逐层更红 → 最后黑屏 + 抖动
     ========================= */
  function resizeFx(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    fx.width = Math.floor(innerWidth * dpr);
    fx.height = Math.floor(innerHeight * dpr);
    fx.style.width = innerWidth + "px";
    fx.style.height = innerHeight + "px";
    fxCtx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resizeFx);
  resizeFx();

  function doShakeOnce(){
    document.documentElement.classList.add("shake");
    document.body.classList.add("shake");
    setTimeout(() => {
      document.documentElement.classList.remove("shake");
      document.body.classList.remove("shake");
    }, 560);
  }

  function drawFlash(progress, nowMs){
    const w = innerWidth, h = innerHeight;
    const cx = w/2, cy = h/2;
    const maxR = Math.hypot(Math.max(cx, w-cx), Math.max(cy, h-cy));

    // ✅ 你要求：闪烁开始背景必须是黑色
    fxCtx.clearRect(0,0,w,h);
    fxCtx.fillStyle = "#000";
    fxCtx.fillRect(0,0,w,h);

    // 扩散半径
    const r = Math.max(1, maxR * progress);

    // 闪烁强度：轻微随机 + 高频抖动（更“爆炸闪”）
    const t = (nowMs || performance.now()) / 1000;
    const flicker = 0.78 + 0.14*Math.sin(t*42) + 0.08*Math.sin(t*19) + (Math.random()*0.06);
    const a0 = Math.max(0.15, Math.min(1.0, flicker));

    // 分层渐变（离散层更符合“外面一层更红”）
    const g = fxCtx.createRadialGradient(cx, cy, 0, cx, cy, r);
    g.addColorStop(0.00, `rgba(255,140,0,${(0.95*a0).toFixed(3)})`);  // 橘
    g.addColorStop(0.18, `rgba(255,70,0,${(0.88*a0).toFixed(3)})`);   // 红橘
    g.addColorStop(0.34, `rgba(220,0,0,${(0.78*a0).toFixed(3)})`);    // 红
    g.addColorStop(0.52, `rgba(150,0,0,${(0.66*a0).toFixed(3)})`);    // 深红
    g.addColorStop(0.72, `rgba(90,0,0,${(0.52*a0).toFixed(3)})`);     // 更深红
    g.addColorStop(1.00, `rgba(0,0,0,0)`);                            // 边缘透明回黑

    fxCtx.fillStyle = g;
    fxCtx.fillRect(0,0,w,h);

    // 额外的“热浪亮圈”（让中心更有爆点感）
    const ringA = 0.18 * a0 * (1 - progress);
    if(ringA > 0.01){
      fxCtx.beginPath();
      fxCtx.arc(cx, cy, Math.min(maxR, r*0.35), 0, Math.PI*2);
      fxCtx.strokeStyle = `rgba(255,180,80,${ringA.toFixed(3)})`;
      fxCtx.lineWidth = 6;
      fxCtx.stroke();
    }
  }

  function runFlashExplosionFx(onDone){
    // ✅ 一开始就显示（避免看到白底）
    fx.style.opacity = "1";
    black.style.opacity = "0";

    // 先画一帧纯黑，确保“开始背景是黑色”
    drawFlash(0.001, performance.now());

    const t0 = performance.now();
    const phaseFlash = 780;   // 闪烁蔓延时长
    const phaseFade  = 260;   // 淡入纯黑
    const phaseHold  = 520;   // 黑屏停留 + 抖动

    let shook = false;

    function tick(now){
      const dt = now - t0;

      if(dt <= phaseFlash){
        const p = dt / phaseFlash;

        // 闪烁蔓延
        drawFlash(p, now);

        // 抖动更像爆炸：一开始就抖一下
        if(!shook && dt > 20){
          shook = true;
          doShakeOnce();
        }

        requestAnimationFrame(tick);
        return;
      }

      if(dt <= phaseFlash + phaseFade){
        const p = (dt - phaseFlash) / phaseFade;
        // 闪烁层淡出，黑层淡入
        fx.style.opacity = String(1 - 0.9*p);
        black.style.opacity = String(p);
        requestAnimationFrame(tick);
        return;
      }

      if(dt <= phaseFlash + phaseFade + phaseHold){
        black.style.opacity = "1";
        // 结尾再来一次冲击抖动
        if(dt <= phaseFlash + phaseFade + 40){
          doShakeOnce();
        }
        requestAnimationFrame(tick);
        return;
      }

      fx.style.opacity = "0";
      black.style.opacity = "1";
      if(typeof onDone === "function") onDone();
    }

    requestAnimationFrame(tick);
  }

  function latchThenExplodeAndGo(){
    if(exploded) return;
    exploded = true;

    // ✅ 0 秒：先“咔嚓”
    playLatch();

    // ✅ 稍后爆炸：爆炸开始时同时进入闪烁画面（不要网格）
    const DELAY_MS = 150; // 机关到爆炸的间隔（你要更短可改 100）
    setTimeout(() => {
      playExplosion();
      runFlashExplosionFx(() => {
        setTimeout(() => {
          location.href = NEXT_URL;
        }, 120);
      });
    }, DELAY_MS);
  }

  function startCountdown(){
    let left = COUNTDOWN_SEC;

    const tick = () => {
      statusEl.textContent = `倒计时：${left}`;

      if(left === 8 && !musicPlayed){
        musicPlayed = true;
        hintEl.style.display = "block";
        playMelody();
      }

      if(left <= 0){
        // ✅ 到 0：咔嚓 -> 爆炸（同时闪烁）-> 黑屏 -> 跳转
        latchThenExplodeAndGo();
        return;
      }

      left--;
      timers.push(setTimeout(tick, 1000));
    };

    tick();
  }

  async function startFlow(){
    startBtn.disabled = true;
    btnRow.style.display = "none";
    centerStack.style.display = "block";
    hintEl.style.display = "none";
    musicPlayed = false;
    exploded = false;

    // 重置覆盖层
    fx.style.opacity = "0";
    black.style.opacity = "0";

    clearTimers();

    try{ await enableAudio(); }catch(e){}
    startCountdown();
  }

  startBtn.addEventListener("click", startFlow);
})();
</script>
</body>
</html>
