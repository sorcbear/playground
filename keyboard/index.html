<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Piano Puzzle</title>

<style>
  html,body{
    margin:0;
    background:#000;
    color:#fff;
    font-family:-apple-system,BlinkMacSystemFont,"PingFang SC","Microsoft YaHei",sans-serif;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  .wrap{max-width:1100px;margin:0 auto;padding:14px;box-sizing:border-box;}
  .hint{font-size:14px;opacity:.92;margin:6px 0 10px;line-height:1.5;}

  .topbar{
    display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;
    margin-bottom:10px;
  }
  .status{font-size:14px;min-height:22px;flex:1 1 240px;}
  .btns{display:flex;gap:10px;flex:0 0 auto;align-items:center;}
  button{
    border:none;border-radius:10px;background:#222;color:#fff;
    padding:10px 14px;font-size:14px;
  }
  button:active{transform:translateY(1px)}
  .ok{background:#0b5;color:#021;font-weight:700}
  .warn{background:#a22;font-weight:700}

  .kbd{
    position:relative;width:100%;
    border-radius:12px;overflow:hidden;
    box-shadow:0 10px 30px rgba(0,0,0,.6);
    background:#111;
  }
  /* 你的图大约 1024x461 */
  .kbd::before{content:"";display:block;padding-top:45.1%;}
  .kbd-bg{
    position:absolute;inset:0;
    background:url("./keyboard.png") center/cover no-repeat;
  }

  /* 点击区域层：只在底部更容易点中的区域判定 */
  .hit-layer{
    position:absolute;inset:0;
    pointer-events:none; /* 默认关闭，单个键开启 */
  }
  .hitkey{
    position:absolute;
    pointer-events:auto;
    background:rgba(255,255,255,0.0);
    border-radius:8px;
  }
  .hitkey.active{
    background:rgba(255,255,255,0.08);
  }

  /* 调试用：显示划分（默认关） */
  .debug .hitkey{
    outline:1px solid rgba(0,255,153,0.35);
    background:rgba(0,255,153,0.06);
  }

  .small{opacity:.75;font-size:12px;margin-top:4px;line-height:1.4;}
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="status" id="status">未开始</div>
    <div class="btns">
      <button id="audioBtn" class="ok">启用声音</button>
      <button id="resetBtn">Reset</button>
      <button id="debugBtn">Debug</button>
    </div>
  </div>

  <div class="hint">
    需要按正确顺序弹奏旋律，并保持节奏均匀（第 1–2 音间隔作为基准）。节奏判定已放宽。
    <div class="small">如果 iPhone 没声音：先点一次“启用声音”。</div>
  </div>

  <div class="kbd" id="kbd">
    <div class="kbd-bg"></div>
    <div class="hit-layer" id="hitLayer"></div>
  </div>
</div>

<script>
(() => {
  /* =========================
     1) 键位定义（16 个白键）
     绿 so la si | 红 do~si | 蓝 do~la
     红 do = C4 (60)
  ========================= */
  const KEYS = [
    {c:"green",n:"so",m:55}, // G3
    {c:"green",n:"la",m:57}, // A3
    {c:"green",n:"si",m:59}, // B3

    {c:"red",n:"do",m:60},   // C4
    {c:"red",n:"re",m:62},   // D4
    {c:"red",n:"mi",m:64},   // E4
    {c:"red",n:"fa",m:65},   // F4
    {c:"red",n:"so",m:67},   // G4
    {c:"red",n:"la",m:69},   // A4
    {c:"red",n:"si",m:71},   // B4

    {c:"blue",n:"do",m:72},  // C5
    {c:"blue",n:"re",m:74},  // D5
    {c:"blue",n:"mi",m:76},  // E5
    {c:"blue",n:"fa",m:77},  // F5
    {c:"blue",n:"so",m:79},  // G5
    {c:"blue",n:"la",m:81},  // A5
  ];
  const keyIndex = new Map();
  KEYS.forEach((k,i)=> keyIndex.set(`${k.c}|${k.n}`, i));

  /* =========================
     2) 正确答案（32 音，与你描述一致）
  ========================= */
  const target = [
    // A
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
    // B
    ["red","do"],["red","re"],["red","la"],["blue","re"],["blue","fa"],["red","la"],["blue","re"],["blue","fa"],
    // C
    ["green","si"],["red","re"],["red","so"],["blue","re"],["blue","fa"],["red","so"],["blue","re"],["blue","fa"],
    // D (=A)
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
  ];

  /* =========================
     3) 节奏判定（放宽）
     - ABS_TOL 绝对容差：从 80ms 放宽到 140ms
     - REL_TOL 相对容差：从 18% 放宽到 30%
     - dt0 合理范围也放宽
  ========================= */
  const ABS_TOL = 0.14;   // 140ms（更宽松）
  const REL_TOL = 0.30;   // 30%
  const DT_MIN  = 0.12;   // 120ms
  const DT_MAX  = 1.60;   // 1600ms

  function tolFor(dt0){ return Math.max(ABS_TOL, dt0 * REL_TOL); }

  /* =========================
     4) WebAudio：银色/明亮钢琴感（无音频文件）
     - iOS 需要“启用声音”一次来 resume
  ========================= */
  let audioCtx = null;
  let audioEnabled = false;

  function ensureAudioCtx(){
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!audioCtx) audioCtx = new AC();
    return audioCtx;
  }

  async function enableAudio(){
    const ctx = ensureAudioCtx();
    if (ctx.state === "suspended") {
      await ctx.resume();
    }
    audioEnabled = true;
  }

  function midiToFreq(m){ return 440 * Math.pow(2, (m - 69) / 12); }

  function playTone(freq, duration = 0.36){
    if (!audioEnabled || !audioCtx) return;

    const now = audioCtx.currentTime;

    const o1 = audioCtx.createOscillator(); // 基音
    const o2 = audioCtx.createOscillator(); // 泛音
    const o3 = audioCtx.createOscillator(); // 轻微击弦感

    o1.type = "sine";
    o2.type = "triangle";
    o3.type = "square";

    o1.frequency.setValueAtTime(freq, now);
    o2.frequency.setValueAtTime(freq * 2, now);
    o3.frequency.setValueAtTime(freq * 4, now);

    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.34, now + 0.012);          // attack 稍慢一点更自然
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    const f = audioCtx.createBiquadFilter();
    f.type = "lowpass";
    f.frequency.setValueAtTime(Math.min(freq * 6, 12000), now);
    f.Q.value = 0.7;

    o1.connect(g); o2.connect(g); o3.connect(g);
    g.connect(f); f.connect(audioCtx.destination);

    o1.start(now); o2.start(now); o3.start(now);
    const stopAt = now + duration + 0.05;
    o1.stop(stopAt); o2.stop(stopAt); o3.stop(stopAt);
  }

  /* =========================
     5) 点击区域：改为“底部区域判定 + 安全边界”
     - 仍按 16 段，但只覆盖 bottom band（更符合手指点击）
     - 并给每段留 margin（避免边界误触）
  ========================= */
  const kbdEl = document.getElementById("kbd");
  const hitLayer = document.getElementById("hitLayer");
  const statusEl = document.getElementById("status");
  const audioBtn = document.getElementById("audioBtn");
  const resetBtn = document.getElementById("resetBtn");
  const debugBtn = document.getElementById("debugBtn");

  // 这些参数专门为“减少误触”而设：
  const BAND_TOP = 0.56;        // 只在下方 44% 高度做判定（靠近标签）
  const BAND_BOTTOM = 1.00;
  const KEY_MARGIN_X = 0.10;    // 每个键左右缩进 10%（减少边界误点）

  const keyDivs = [];

  function buildHitKeys(){
    hitLayer.innerHTML = "";
    keyDivs.length = 0;

    for (let i=0;i<16;i++){
      const d = document.createElement("div");
      d.className = "hitkey";
      d.dataset.i = String(i);

      // 定位：百分比
      const segW = 100 / 16;
      const left = i * segW;
      const innerLeft = left + segW * KEY_MARGIN_X;
      const innerW = segW * (1 - 2*KEY_MARGIN_X);

      d.style.left = innerLeft + "%";
      d.style.width = innerW + "%";
      d.style.top = (BAND_TOP * 100) + "%";
      d.style.height = ((BAND_BOTTOM - BAND_TOP) * 100) + "%";

      // 多事件兼容：pointer / touch / mouse
      const handler = async (ev) => {
        ev.preventDefault();
        // 如果没启用声音，仍允许弹，但提示
        if (!audioEnabled) {
          statusEl.textContent = "请先点“启用声音”";
          statusEl.style.color = "#ffd36b";
        }
        pressKey(i);
      };

      d.addEventListener("pointerdown", handler, {passive:false});
      d.addEventListener("touchstart", handler, {passive:false});
      d.addEventListener("mousedown", handler, {passive:false});

      hitLayer.appendChild(d);
      keyDivs.push(d);
    }
  }

  function flashKey(i){
    const d = keyDivs[i];
    if (!d) return;
    d.classList.add("active");
    setTimeout(()=>d.classList.remove("active"), 90);
  }

  /* =========================
     6) 判定逻辑（音符 + 节奏）
  ========================= */
  let step = 0;
  let t1=null, t2=null, dt0=null, last=null;

  function reset(msg="未开始"){
    step=0; t1=t2=dt0=last=null;
    statusEl.textContent = msg;
    statusEl.style.color = "#fff";
  }

  function fail(msg){
    reset("失败：" + msg + "（已重置）");
    statusEl.style.color = "#ff6b6b";
  }

  function pressKey(i){
    flashKey(i);

    const k = KEYS[i];
    // 发声（若未启用则静默）
    if (audioEnabled) playTone(midiToFreq(k.m), 0.36);

    // 成功后不再判定
    if (step >= target.length){
      return;
    }

    const [tc, tn] = target[step];
    const needIdx = keyIndex.get(`${tc}|${tn}`);
    if (needIdx === undefined){
      fail("内部配置错误（找不到目标键）");
      return;
    }

    if (i !== needIdx){
      fail(`音符错误：应为 ${tc}${tn}`);
      return;
    }

    const now = performance.now() / 1000;

    if (step === 0){
      t1 = now;
      last = now;
      step++;
      statusEl.textContent = `进度 ${step}/${target.length}（等待建立基准间隔）`;
      return;
    }

    if (step === 1){
      t2 = now;
      dt0 = t2 - t1;
      if (dt0 < DT_MIN || dt0 > DT_MAX){
        fail(`第1-2音间隔 dt0=${dt0.toFixed(3)}s 不合理`);
        return;
      }
      last = now;
      step++;
      statusEl.textContent = `进度 ${step}/${target.length}（dt0=${dt0.toFixed(3)}s，容差±${tolFor(dt0).toFixed(3)}s）`;
      return;
    }

    const dt = now - last;
    const tol = tolFor(dt0);

    if (Math.abs(dt - dt0) > tol){
      fail(`节奏不均匀：dt=${dt.toFixed(3)}s，dt0=${dt0.toFixed(3)}s（容差±${tol.toFixed(3)}s）`);
      return;
    }

    last = now;
    step++;

    if (step === target.length){
      statusEl.textContent = "success";
      statusEl.style.color = "#00ff99";
    } else {
      statusEl.textContent = `进度 ${step}/${target.length}（dt0=${dt0.toFixed(3)}s，容差±${tolFor(dt0).toFixed(3)}s）`;
      statusEl.style.color = "#fff";
    }
  }

  /* =========================
     7) 按钮：启用声音 / Reset / Debug
  ========================= */
  audioBtn.addEventListener("click", async () => {
    try{
      await enableAudio();
      audioBtn.textContent = "声音已启用";
      audioBtn.disabled = true;
      statusEl.textContent = "声音已启用，开始弹奏";
      statusEl.style.color = "#00ff99";
    }catch(e){
      statusEl.textContent = "启用声音失败（请再点一次）";
      statusEl.style.color = "#ff6b6b";
    }
  });

  resetBtn.addEventListener("click", () => reset("已重置"));

  let debug = false;
  debugBtn.addEventListener("click", () => {
    debug = !debug;
    document.body.classList.toggle("debug", debug);
    debugBtn.textContent = debug ? "Debug On" : "Debug";
  });

  // 防止双击缩放影响触控
  document.addEventListener("dblclick", (e)=>e.preventDefault(), {passive:false});

  // 初始化
  buildHitKeys();
  reset("未开始");
})();
</script>
</body>
</html>
