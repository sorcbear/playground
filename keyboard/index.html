<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<meta name="format-detection" content="telephone=no,address=no,email=no">
<title>Piano Puzzle</title>

<style>
:root{
  --maxw: 720px;

  --fs-body: 18px;
  --lh-body: 1.6;

  --fs-hint: 18px;
  --lh-hint: 1.6;

  --fs-btn: 18px;
  --fw-btn: 600;
  --h-btn: 52px;

  --gap: 18px;
  --gap-tight: 12px;

  --c-text:#111;
  --c-border:#000;
  --c-danger:#b00020;

  /* ✅ 稍微更深一点的绿 */
  --c-green:#0ea965;

  --bg:#fff;

  /* ✅ 固定“状态区”两行高度（避免不同提示语导致下面键盘上下跳） */
  --status-2line-h: calc(var(--fs-hint) * var(--lh-hint) * 2);
}

*{ box-sizing:border-box; }
html,body{ height:100%; }

body{
  margin:0;
  background:var(--bg);
  color:var(--c-text);
  font-family: system-ui, -apple-system, "PingFang SC","Microsoft YaHei", Arial, sans-serif;
  font-size:var(--fs-body);
  line-height:var(--lh-body);
  -webkit-text-size-adjust:100%;
  -webkit-tap-highlight-color:transparent;
  user-select:none;
}

.wrap{
  max-width:var(--maxw);
  margin:0 auto;
  padding:18px 14px 28px;
}

/* 顶部说明（合并后的整段） */
.title{
  font-size:var(--fs-hint);
  line-height:var(--lh-hint);
  font-weight:700;
  margin:4px 0 50px;
  text-align:left;
  white-space:pre-wrap;
}
.title .greenWord{
  color:var(--c-green);
  font-weight:800;
}

.statusTitle{
  font-size:var(--fs-hint);
  line-height:var(--lh-hint);
  font-weight:700;
  margin:0;
  white-space:pre-wrap;
  min-height: var(--status-2line-h);
}

.statusFail{ color:var(--c-danger); font-weight:800; }
.statusOk{ color:var(--c-green); font-weight:800; }

/* 顶部栏 */
.topbar{
  display:flex;
  gap:10px;
  align-items:stretch;
  justify-content:space-between;
  margin:0 0 var(--gap-tight);
}
.btnsTop{
  display:flex;
  gap:10px;
  flex:0 0 auto;
  align-items:stretch;
}

/* 同源按钮：直角 */
button{
  height:var(--h-btn);
  padding:0 18px;
  box-sizing:border-box;
  font-size:var(--fs-btn);
  font-weight:var(--fw-btn);
  background:#fff;
  color:#000;
  border:2px solid var(--c-border);
  cursor:pointer;
  border-radius:0;
  -webkit-tap-highlight-color:transparent;
  font-family:inherit;
  transition:none;
}
@media (hover:hover) and (pointer:fine){
  button:hover{ background:#000; color:#fff; }
}
button.invert{ background:#000; color:#fff; }
button:disabled{ opacity:.45; cursor:default; }

/* 顶部两个按钮：按内容自适应 + ✅ 高度跟随状态两行高度（上下沿对齐） */
.btnSmall{
  width:auto;
  height:100%;
  padding:0 14px;
  font-size:16px;
  white-space:nowrap;
}
.btnAudio{ min-width: 132px; }
.btnReset{ min-width: 72px; }

/* 启动声音：深绿底，字黑；禁用不变淡 */
.okBtn{
  background:var(--c-green);
  border:2px solid var(--c-green);
  color:#000;
  font-weight:800;
}
.okBtn:disabled{ opacity:1; cursor:default; }
@media (hover:hover) and (pointer:fine){
  .okBtn:hover{ background:var(--c-green); color:#000; }
}

/* 键盘区域 */
.kbd{
  position:relative;
  width:100%;
  overflow:hidden;
  background:#fff;
  touch-action:none;
  margin:0 0 var(--gap-tight);
  aspect-ratio: 1024 / 461;
}
.kbd-inner{position:absolute;inset:0;display:flex;align-items:flex-start;justify-content:center;}
#kbdImg{
  width:100%;
  height:100%;
  object-fit:contain;
  object-position:center top;
  display:block;
  pointer-events:none;
  background:#fff;
}

.overlay{position:absolute;inset:0;pointer-events:none;}
.segbox{position:absolute;top:0;bottom:0;outline:1px solid rgba(0,160,90,.70);background:rgba(0,160,90,.06);display:none;}
.debug .segbox{display:block;}

.debugRow{
  display:flex;
  justify-content:center;
  margin-top: var(--gap-tight);
}
.debugRow button{ width:240px; }

@media (max-width:520px){
  .btnAudio{ min-width: 124px; }
  .btnReset{ min-width: 68px; }
}

/* =========================
   ✅ Start Game 同款爆炸层（完全一样）
   ========================= */
#fx{
  position:fixed;
  inset:0;
  width:100vw;
  height:100vh;
  pointer-events:none;
  z-index:9999;
  opacity:0;
}

@keyframes shake {
  0%{ transform:translate(0,0); }
  15%{ transform:translate(-9px,7px); }
  30%{ transform:translate(8px,-7px); }
  45%{ transform:translate(-7px,-9px); }
  60%{ transform:translate(7px,9px); }
  75%{ transform:translate(-5px,7px); }
  90%{ transform:translate(5px,-7px); }
  100%{ transform:translate(0,0); }
}
.shake{ animation:shake 0.55s ease-in-out; }
</style>
</head>

<body>
<div class="wrap">

  <div class="title">拿出道具包里的【五线谱】，根据上题答案，找到正确的曲谱片段，按照顺序演奏乐曲（2,7,4,2）。相邻两次点击间隔需≤ 5 秒（超时算作失败将重置）。弹奏前需点击“<span class="greenWord">启动声音</span>”，手机建议横屏操作。</div>

  <div class="topbar">
    <div class="statusTitle" id="status">未开始</div>
    <div class="btnsTop">
      <button id="audioBtn" class="btnSmall btnAudio okBtn">启动声音</button>
      <button id="resetBtn" class="btnSmall btnReset">重置</button>
    </div>
  </div>

  <div class="kbd" id="kbd">
    <div class="kbd-inner">
      <img id="kbdImg" src="./keyboard.png" alt="keyboard" />
    </div>
    <div class="overlay" id="overlay"></div>
  </div>

  <div class="debugRow">
    <button id="debugBtn">Debug</button>
  </div>

</div>

<!-- ✅ Start Game 同款爆炸 canvas -->
<canvas id="fx"></canvas>

<script>
(() => {
  const FIX_N = 12;
  const FIX_OFFSET = 2;
  const MAX_GAP = 5.0;

  const GLOBAL_NUDGE = 0;
  const NEXT_URL = "https://sorcbear.github.io/playground/end/";
  const BOUNDARY_SCALE = 0.9920;

  /* ✅ 成功后倒计时（同你之前要求） */
  const COUNTDOWN_START = 3;

  /* ✅ Start Game 同款爆炸时序（完全一样） */
  const PAUSE_BEFORE_LATCH_MS = 1000;
  const LATCH_TO_BOOM_MS = 500;

  const KEYS = [
    {c:"green",n:"so",m:55},
    {c:"green",n:"la",m:57},
    {c:"green",n:"si",m:59},
    {c:"red",n:"do",m:60},
    {c:"red",n:"re",m:62},
    {c:"red",n:"mi",m:64},
    {c:"red",n:"fa",m:65},
    {c:"red",n:"so",m:67},
    {c:"red",n:"la",m:69},
    {c:"red",n:"si",m:71},
    {c:"blue",n:"do",m:72},
    {c:"blue",n:"re",m:74},
    {c:"blue",n:"mi",m:76},
    {c:"blue",n:"fa",m:77},
    {c:"blue",n:"so",m:79},
    {c:"blue",n:"la",m:81},
  ];

  const target = [
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
    ["red","do"],["red","re"],["red","la"],["blue","re"],["blue","fa"],["red","la"],["blue","re"],["blue","fa"],
    ["green","si"],["red","re"],["red","so"],["blue","re"],["blue","fa"],["red","so"],["blue","re"],["blue","fa"],
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
  ];

  let audioCtx=null, audioEnabled=false;

  function ensureAudioCtx(){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!audioCtx) audioCtx = new AC();
    return audioCtx;
  }
  async function enableAudio(){
    const ctx = ensureAudioCtx();
    if(ctx.state==="suspended") await ctx.resume();
    audioEnabled = true;
  }

  function midiToFreq(m){ return 440*Math.pow(2,(m-69)/12); }
  function playTone(freq, duration=1.25){
    if(!audioEnabled || !audioCtx) return;
    const now = audioCtx.currentTime;

    const o1=audioCtx.createOscillator(), o2=audioCtx.createOscillator(), o3=audioCtx.createOscillator();
    o1.type="sine"; o2.type="triangle"; o3.type="square";
    o1.frequency.setValueAtTime(freq, now);
    o2.frequency.setValueAtTime(freq*2, now);
    o3.frequency.setValueAtTime(freq*4, now);

    const g1=audioCtx.createGain(); g1.gain.value=1.0;
    const g2=audioCtx.createGain(); g2.gain.value=0.55;
    const g3=audioCtx.createGain(); g3.gain.value=0.06;

    const amp=audioCtx.createGain();
    amp.gain.setValueAtTime(0.0001, now);
    amp.gain.linearRampToValueAtTime(0.33, now+0.015);
    amp.gain.exponentialRampToValueAtTime(0.0001, now+duration);

    const lp=audioCtx.createBiquadFilter();
    lp.type="lowpass";
    lp.frequency.setValueAtTime(Math.min(freq*6, 9000), now);
    lp.Q.value=0.85;

    o1.connect(g1); g1.connect(amp);
    o2.connect(g2); g2.connect(amp);
    o3.connect(g3); g3.connect(amp);
    amp.connect(lp); lp.connect(audioCtx.destination);

    o1.start(now); o2.start(now); o3.start(now);
    const stopAt = now+duration+0.12;
    o1.stop(stopAt); o2.stop(stopAt); o3.stop(stopAt);
  }

  const kbd=document.getElementById("kbd");
  const img=document.getElementById("kbdImg");
  const overlay=document.getElementById("overlay");
  const statusEl=document.getElementById("status");
  const audioBtn=document.getElementById("audioBtn");
  const resetBtn=document.getElementById("resetBtn");
  const debugBtn=document.getElementById("debugBtn");

  /* ✅ Start Game 同款爆炸 canvas/context */
  const fx = document.getElementById("fx");
  const fxCtx = fx.getContext("2d", { alpha:true });

  let boundaries=null;
  let segBoxes=[];
  let boundarySource="";

  function fallbackEqualBoundaries(n){
    const iw = img.naturalWidth || 1024;
    const bds=[0];
    for(let i=1;i<n;i++) bds.push(iw*i/n);
    bds.push(iw);
    return bds;
  }

  function applyScaleToBoundaries(bds, scale){
    const iw = img.naturalWidth || 1024;
    const center = iw * 0.5;
    const out = bds.slice();

    for(let i=1;i<out.length-1;i++){
      out[i] = center + (out[i]-center) * scale;
    }

    out[0]=0; out[out.length-1]=iw;
    const eps = 1e-6;
    for(let i=1;i<out.length;i++){
      if(out[i] <= out[i-1]) out[i] = out[i-1] + eps;
      if(out[i] > iw) out[i] = iw;
    }
    for(let i=out.length-2;i>=0;i--){
      if(out[i] >= out[i+1]) out[i] = out[i+1] - eps;
      if(out[i] < 0) out[i] = 0;
    }
    out[0]=0; out[out.length-1]=iw;
    return out;
  }

  function detectBoundaries12BySeparators(){
    const iw=img.naturalWidth, ih=img.naturalHeight;
    if(!iw||!ih) return null;

    const canvas=document.createElement("canvas");
    canvas.width=iw; canvas.height=ih;
    const ctx=canvas.getContext("2d",{willReadFrequently:true});
    ctx.drawImage(img,0,0,iw,ih);

    const y0=Math.floor(ih*0.66);
    const y1=Math.floor(ih*0.90);
    const h=Math.max(1,y1-y0);
    const data=ctx.getImageData(0,y0,iw,h).data;

    const raw=new Float32Array(iw);
    for(let x=0;x<iw;x++){
      let s=0;
      for(let y=0;y<h;y++){
        const i=(y*iw+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2];
        if(r<60 && g<60 && b<60) s++;
      }
      raw[x]=s;
    }

    const tmp=Array.from(raw).sort((a,b)=>a-b);
    const baseline=tmp[Math.floor(tmp.length*0.5)];
    for(let x=0;x<iw;x++) raw[x]=Math.max(0, raw[x]-baseline);

    const smooth=new Float32Array(iw);
    const W=5;
    let maxv=0;
    for(let x=0;x<iw;x++){
      let sum=0,cnt=0;
      for(let k=-W;k<=W;k++){
        const xx=x+k;
        if(xx>=0 && xx<iw){ sum+=raw[xx]; cnt++; }
      }
      const v=sum/cnt;
      smooth[x]=v;
      if(v>maxv) maxv=v;
    }
    if(maxv < h*0.08) return null;

    const thresh=maxv*0.45;
    const peaks=[];
    for(let x=2;x<iw-2;x++){
      const v=smooth[x];
      if(v<thresh) continue;
      if(v>=smooth[x-1] && v>=smooth[x+1] && v>=smooth[x-2] && v>=smooth[x+2]){
        peaks.push({x, v});
      }
    }
    if(peaks.length < 11) return null;

    peaks.sort((a,b)=>b.v-a.v);
    const need = FIX_N - 1;
    const minDist = Math.floor(iw/(FIX_N*1.20));
    const chosen=[];
    for(const p of peaks){
      if(p.x < iw*0.02 || p.x > iw*0.98) continue;
      let ok=true;
      for(const q of chosen){
        if(Math.abs(p.x - q.x) < minDist){ ok=false; break; }
      }
      if(!ok) continue;
      chosen.push(p);
      if(chosen.length===need) break;
    }
    if(chosen.length!==need) return null;
    chosen.sort((a,b)=>a.x-b.x);

    function snapSmall(x0){
      const R = 4;
      const L = Math.max(2, x0 - R);
      const Rr = Math.min(iw - 3, x0 + R);

      let bestX=x0, bestV=-1;
      for(let x=L;x<=Rr;x++){
        const v=raw[x];
        if(v>bestV){ bestV=v; bestX=x; }
      }
      if(bestV<=0) return bestX;

      const th = bestV * 0.90;
      let a=bestX, b=bestX;
      while(a>L  && raw[a-1] >= th) a--;
      while(b<Rr && raw[b+1] >= th) b++;
      return (a+b)/2;
    }

    const refined = chosen.map(p => snapSmall(p.x) + GLOBAL_NUDGE);
    const bds=[0, ...refined, iw];
    const eps=1e-6;
    for(let i=1;i<bds.length;i++){
      if(bds[i]<=bds[i-1]) bds[i]=bds[i-1]+eps;
    }
    return bds;
  }

  function buildOverlay(){
    overlay.innerHTML="";
    segBoxes=[];
    if(!boundaries) return;
    for(let i=0;i<FIX_N;i++){
      const box=document.createElement("div");
      box.className="segbox";
      overlay.appendChild(box);
      segBoxes.push(box);
    }
    layoutOverlay();
  }

  function layoutOverlay(){
    if(!boundaries || segBoxes.length!==FIX_N) return;

    const kbr = kbd.getBoundingClientRect();
    const ir  = img.getBoundingClientRect();
    const iw  = img.naturalWidth || 1024;

    const offsetX = ir.left - kbr.left;
    const w = ir.width;

    for(let i=0;i<FIX_N;i++){
      const x0 = offsetX + (boundaries[i]   / iw) * w;
      const x1 = offsetX + (boundaries[i+1] / iw) * w;
      segBoxes[i].style.left  = x0 + "px";
      segBoxes[i].style.width = Math.max(0, x1-x0) + "px";
    }
  }

  function pointToLocalIndex(clientX, clientY){
    const ir = img.getBoundingClientRect();
    if(clientX<ir.left || clientX>ir.right || clientY<ir.top || clientY>ir.bottom) return null;

    const iw = img.naturalWidth || 1024;
    const ih = img.naturalHeight || 461;

    const yNat = (clientY - ir.top) / ir.height * ih;
    if(yNat < ih*0.52) return null;

    const xNat = (clientX - ir.left) / ir.width * iw;
    const bds = boundaries || fallbackEqualBoundaries(FIX_N);

    let lo=0, hi=FIX_N-1;
    while(lo<=hi){
      const mid=(lo+hi)>>1;
      if(xNat < bds[mid]) hi=mid-1;
      else if(xNat >= bds[mid+1]) lo=mid+1;
      else return mid;
    }
    return null;
  }

  let step=0, lastTime=null;

  /* ✅ 成功后锁定与倒计时 */
  let locked=false;
  let timer=null;

  function setLocked(v){
    locked=v;
    audioBtn.disabled = v || audioBtn.disabled;
    resetBtn.disabled = v;
    debugBtn.disabled = v;
  }

  function setStatus(text, cls){
    statusEl.textContent = text;
    statusEl.classList.remove("statusFail","statusOk");
    if(cls) statusEl.classList.add(cls);
  }

  function reset(msg="未开始"){
    if(timer){ clearInterval(timer); timer=null; }
    locked=false;
    setLocked(false);

    // ✅ 若爆炸层还在，复位为透明（不影响其它逻辑）
    fx.style.opacity = "0";

    step=0; lastTime=null;
    setStatus(msg, "");
  }

  function fail(msg){
    if(locked) return;
    setStatus("失败：" + msg + "（已重置）", "statusFail");
    step=0; lastTime=null;
  }
  function timeoutReset(){
    if(locked) return;
    setStatus("失败：超时（已重置）", "statusFail");
    step=0; lastTime=null;
  }

  /* =========================================================
     ✅ Start Game 同款爆炸：视觉 + shake + latch/boom 音效
     （只在成功倒计时结束触发，不改其它路径）
     ========================================================= */

  function resizeFx(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    fx.width = Math.floor(innerWidth * dpr);
    fx.height = Math.floor(innerHeight * dpr);
    fx.style.width = innerWidth + "px";
    fx.style.height = innerHeight + "px";
    fxCtx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener("resize", resizeFx);
  resizeFx();

  function doShakeOnce(){
    document.documentElement.classList.add("shake");
    document.body.classList.add("shake");
    setTimeout(() => {
      document.documentElement.classList.remove("shake");
      document.body.classList.remove("shake");
    }, 560);
  }

  const RINGS = ["#ff6a00","#c84500","#b00000","#000000"];

  function squareDistNorm(x, y, cx, cy, maxD){
    const dx = Math.abs(x - cx);
    const dy = Math.abs(y - cy);
    return Math.min(1, Math.max(dx, dy) / maxD);
  }

  function drawSquareExpand(progress){
    const w = innerWidth, h = innerHeight;
    const cx = w/2, cy = h/2;
    const maxD = Math.max(cx, w - cx, cy, h - cy);

    const hc = navigator.hardwareConcurrency || 8;
    const cell = (hc <= 4) ? 28 : 22;

    fxCtx.fillStyle = "#000";
    fxCtx.fillRect(0,0,w,h);

    const front = Math.min(1, progress);
    const step = 0.085;

    for(let y=0; y<h; y+=cell){
      for(let x=0; x<w; x+=cell){
        const gx = x + cell/2;
        const gy = y + cell/2;

        const dn = squareDistNorm(gx, gy, cx, cy, maxD);
        if(dn > front) continue;

        const ratio = dn / Math.max(0.0001, front);
        const band = Math.min(1, Math.floor(ratio / step) * step);

        const idx = Math.min(RINGS.length - 1, Math.floor(band * (RINGS.length)));
        fxCtx.fillStyle = RINGS[idx];
        fxCtx.fillRect(x, y, cell, cell);
      }
    }
  }

  function runSquareExplosionFx(onDone){
    fx.style.opacity = "1";

    const t0 = performance.now();
    const phaseExpand = 920;
    const phaseHoldBlack = 220;
    const TOTAL_MS = phaseExpand + phaseHoldBlack;

    let shook = false;
    let doneCalled = false;

    const hardTimeout = setTimeout(() => {
      if(doneCalled) return;
      doneCalled = true;
      try { onDone && onDone(); } catch(e) {}
    }, TOTAL_MS + 600);

    function finish(){
      if(doneCalled) return;
      doneCalled = true;
      clearTimeout(hardTimeout);
      if(typeof onDone === "function") onDone();
    }

    function tick(now){
      const dt = now - t0;

      if(dt <= phaseExpand){
        const p = dt / phaseExpand;
        drawSquareExpand(p);

        if(!shook && p > 0.42){
          shook = true;
          doShakeOnce();
        }

        requestAnimationFrame(tick);
        return;
      }

      fxCtx.fillStyle = "#000";
      fxCtx.fillRect(0,0,innerWidth,innerHeight);

      if(dt <= TOTAL_MS){
        requestAnimationFrame(tick);
        return;
      }

      finish();
    }

    requestAnimationFrame(tick);
  }

  function playLatch(){
    if(!audioEnabled || !audioCtx) return;
    const ctx = audioCtx;
    const t0 = ctx.currentTime;

    const outGain = ctx.createGain();
    outGain.gain.setValueAtTime(1.0, t0);
    outGain.connect(ctx.destination);

    const o1 = ctx.createOscillator();
    const g1 = ctx.createGain();
    o1.type = "square";
    o1.frequency.setValueAtTime(260, t0);
    o1.frequency.exponentialRampToValueAtTime(150, t0 + 0.12);
    g1.gain.setValueAtTime(0.0001, t0);
    g1.gain.linearRampToValueAtTime(0.95, t0 + 0.008);
    g1.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.18);
    o1.connect(g1);
    g1.connect(outGain);
    o1.start(t0);
    o1.stop(t0 + 0.20);

    const t1 = t0 + 0.18;
    const o2 = ctx.createOscillator();
    const g2 = ctx.createGain();
    o2.type = "square";
    o2.frequency.setValueAtTime(210, t1);
    o2.frequency.exponentialRampToValueAtTime(120, t1 + 0.10);
    g2.gain.setValueAtTime(0.0001, t1);
    g2.gain.linearRampToValueAtTime(0.88, t1 + 0.008);
    g2.gain.exponentialRampToValueAtTime(0.0001, t1 + 0.16);
    o2.connect(g2);
    g2.connect(outGain);
    o2.start(t1);
    o2.stop(t1 + 0.18);

    const dur = 0.42;
    const bufferSize = Math.floor(ctx.sampleRate * dur);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<bufferSize;i++){
      const x = i / bufferSize;
      const raw = (Math.random()*2-1);
      data[i] = raw * (0.55*(1-x));
    }
    const src = ctx.createBufferSource();
    src.buffer = buffer;

    const hp = ctx.createBiquadFilter();
    hp.type = "highpass";
    hp.frequency.setValueAtTime(900, t0);

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.setValueAtTime(1900, t0);
    bp.Q.setValueAtTime(6, t0);

    const ng = ctx.createGain();
    ng.gain.setValueAtTime(0.0001, t0);
    ng.gain.linearRampToValueAtTime(0.72, t0 + 0.02);
    ng.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

    src.connect(hp);
    hp.connect(bp);
    bp.connect(ng);
    ng.connect(outGain);

    src.start(t0);
    src.stop(t0 + dur);
  }

  function playExplosion(){
    if(!audioEnabled || !audioCtx) return;
    const ctx = audioCtx;

    const duration = 0.90;
    const bufferSize = Math.floor(ctx.sampleRate * duration);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);

    for(let i=0;i<bufferSize;i++){
      const x = i / bufferSize;
      const noise = (Math.random()*2-1);
      const thump = Math.sin(2*Math.PI*50*x) * (1-x);
      const punch = (x < 0.16) ? 1.55 : 1.0;
      data[i] = (noise*1.05 + thump*0.60) * (1 - x) * punch;
    }

    const src = ctx.createBufferSource();
    src.buffer = buffer;

    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.setValueAtTime(1600, ctx.currentTime);
    lp.frequency.exponentialRampToValueAtTime(420, ctx.currentTime + duration);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(1.0, ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration);

    const outGain = ctx.createGain();
    outGain.gain.setValueAtTime(1.0, ctx.currentTime);
    outGain.connect(ctx.destination);

    src.connect(lp);
    lp.connect(gain);
    gain.connect(outGain);

    src.start();
  }

  function latchThenExplodeAndGo(){
    // 复用 Start Game 的时序：先等 1s，再 latch；再等 0.5s boom + fx；fx done 后跳转
    setTimeout(() => {
      playLatch();

      setTimeout(() => {
        playExplosion();

        runSquareExplosionFx(() => {
          setTimeout(() => { location.href = NEXT_URL; }, 80);
        });

      }, LATCH_TO_BOOM_MS);

    }, PAUSE_BEFORE_LATCH_MS);
  }

  function startSuccessCountdown(){
    if(timer){ clearInterval(timer); timer=null; }
    setLocked(true);
    locked=true;

    let t = COUNTDOWN_START;
    setStatus(`答案正确，即将进入下一题（${t}）`, "statusOk");

    timer = setInterval(()=>{
      t--;

      if(t >= 0){
        setStatus(`答案正确，即将进入下一题（${t}）`, "statusOk");
      }else{
        clearInterval(timer);
        timer=null;
        latchThenExplodeAndGo(); // ✅ 0 显示完 1 秒后才爆炸
      }
    }, 1000);
  }

  function pressLocal(localIdx){
    if(locked) return;

    const globalIdx = FIX_OFFSET + localIdx;
    if(globalIdx < 0 || globalIdx >= 16) return;

    const key = KEYS[globalIdx];
    if(audioEnabled) playTone(midiToFreq(key.m), 1.25);

    const now = performance.now()/1000;
    if(lastTime !== null && (now-lastTime) > MAX_GAP){
      timeoutReset();
      return;
    }
    lastTime = now;

    if(step >= target.length) return;

    const [tc, tn] = target[step];
    const needIdx = KEYS.findIndex(k => k.c===tc && k.n===tn);
    if(needIdx < 0){ fail("内部配置错误"); return; }

    if(needIdx < FIX_OFFSET || needIdx >= FIX_OFFSET + FIX_N){
      fail("当前键盘图片缺少必要琴键");
      return;
    }

    if(globalIdx !== needIdx){
      fail("音符错误");
      return;
    }

    step++;
    if(step === target.length){
      // ✅ 成功后：3秒倒计时（你原要求）→ 倒计时结束触发爆炸
      startSuccessCountdown();
    } else {
      setStatus(`进度 ${step}/${target.length}`, "statusOk");
    }
  }

  let lastDownAt = 0;
  function handlePointerDown(ev){
    if(locked) return;

    const t = performance.now();
    if(t - lastDownAt < 50) return;
    lastDownAt = t;

    ev.preventDefault();
    const localIdx = pointToLocalIndex(ev.clientX, ev.clientY);
    if(localIdx === null) return;
    pressLocal(localIdx);
  }
  kbd.addEventListener("pointerdown", handlePointerDown, {passive:false});

  function relayoutAll(){ layoutOverlay(); }
  window.addEventListener("resize", relayoutAll);

  function flashInvert(btn, ms=120){
    btn.classList.add("invert");
    setTimeout(()=>btn.classList.remove("invert"), ms);
  }

  /* ✅ 声音按钮：完全不闪 */
  audioBtn.addEventListener("click", async ()=>{
    if(locked) return;
    try{
      await enableAudio();
      audioBtn.textContent="声音已启用";
      audioBtn.disabled=true;
      setStatus("声音已启用，开始弹奏", "statusOk");
    }catch(e){
      setStatus("失败：启用声音失败（请再点一次）", "statusFail");
    }
  });

  /* ✅ 重置按钮：保留闪 */
  resetBtn.addEventListener("click", ()=>{
    if(locked) return;
    flashInvert(resetBtn,120);
    reset("已重置");
  });

  debugBtn.addEventListener("click", ()=>{
    if(locked) return;
    flashInvert(debugBtn,120);
    const on = document.body.classList.toggle("debug");
    debugBtn.textContent = on ? "Debug On" : "Debug";
    if(on){
      setStatus(`Debug: ${boundarySource || "?"}, scale=${BOUNDARY_SCALE}, dpr=${window.devicePixelRatio || 1}`, "");
      layoutOverlay();
    }else{
      reset("未开始");
    }
  });

  img.addEventListener("load", ()=>{
    const iw = img.naturalWidth || 1024;
    const ih = img.naturalHeight || 461;
    kbd.style.aspectRatio = `${iw} / ${ih}`;

    let bds = detectBoundaries12BySeparators();
    if(!bds || bds.length !== FIX_N+1){
      boundarySource = "fallback";
      bds = fallbackEqualBoundaries(FIX_N);
    }else{
      boundarySource = "detected";
    }

    boundaries = applyScaleToBoundaries(bds, BOUNDARY_SCALE);
    buildOverlay();
    reset("未开始");
  });

  reset("未开始");
})();
</script>
</body>
</html>
