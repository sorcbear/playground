<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Piano Puzzle</title>
<style>
  html,body{margin:0;background:#000;color:#fff;font-family:-apple-system,BlinkMacSystemFont,"PingFang SC","Microsoft YaHei",sans-serif;user-select:none;-webkit-tap-highlight-color:transparent;}
  .wrap{max-width:1100px;margin:0 auto;padding:14px;box-sizing:border-box;}
  .topbar{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;margin-bottom:10px;}
  .status{font-size:14px;min-height:22px;flex:1 1 260px;opacity:.95;}
  .btns{display:flex;gap:10px;flex:0 0 auto;}
  button{border:none;border-radius:10px;background:#222;color:#fff;padding:10px 14px;font-size:14px;cursor:pointer;}
  button:active{transform:translateY(1px)}
  .ok{background:#0b5;color:#021;font-weight:700}
  .hint{font-size:14px;opacity:.9;line-height:1.5;margin:6px 0 10px;}
  .small{opacity:.75;font-size:12px;margin-top:4px;line-height:1.4;}

  .kbd{
    position:relative;width:100%;
    border-radius:12px;overflow:hidden;
    box-shadow:0 10px 30px rgba(0,0,0,.6);
    background:#111;
  }
  /* 你的图约 1024x461 */
  .kbd::before{content:"";display:block;padding-top:45.1%;}
  .kbd-inner{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;}
  #kbdImg{
    width:100%;height:100%;
    object-fit:contain; /* 不裁切 */
    object-position:center;
    display:block;
    pointer-events:none;
  }

  /* Debug 叠加层 */
  .overlay{position:absolute;inset:0;pointer-events:none;}
  .segbox{
    position:absolute;
    top:0;bottom:0;
    outline:1px solid rgba(0,255,153,0.45);
    background:rgba(0,255,153,0.06);
    display:none;
  }
  .debug .segbox{display:block;}
  .flash{
    position:absolute;
    top:56%;
    height:44%;
    background:rgba(255,255,255,0.12);
    border-radius:10px;
    opacity:0;
    transition:opacity 70ms linear;
    pointer-events:none;
  }
  .flash.on{opacity:1;}
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="status" id="status">未开始</div>
    <div class="btns">
      <button id="audioBtn" class="ok">启用声音</button>
      <button id="resetBtn">Reset</button>
      <button id="debugBtn">Debug</button>
    </div>
  </div>

  <div class="hint">
    只要按对音符顺序即可；相邻两次点击间隔必须 ≤ 2 秒（超过则失败重置）。
    <div class="small">iPhone：先点一次“启用声音”。</div>
  </div>

  <div class="kbd" id="kbd">
    <div class="kbd-inner">
      <img id="kbdImg" src="./keyboard.png" alt="keyboard" />
    </div>
    <div class="overlay" id="overlay"></div>
  </div>
</div>

<script>
(() => {
  /* =========================
     1) 16 个键的音高定义（红 do = C4）
  ========================= */
  const KEYS = [
    {c:"green",n:"so",m:55},
    {c:"green",n:"la",m:57},
    {c:"green",n:"si",m:59},

    {c:"red",n:"do",m:60},
    {c:"red",n:"re",m:62},
    {c:"red",n:"mi",m:64},
    {c:"red",n:"fa",m:65},
    {c:"red",n:"so",m:67},
    {c:"red",n:"la",m:69},
    {c:"red",n:"si",m:71},

    {c:"blue",n:"do",m:72},
    {c:"blue",n:"re",m:74},
    {c:"blue",n:"mi",m:76},
    {c:"blue",n:"fa",m:77},
    {c:"blue",n:"so",m:79},
    {c:"blue",n:"la",m:81},
  ];

  const keyIndex = new Map();
  KEYS.forEach((k,i)=>keyIndex.set(`${k.c}|${k.n}`, i));

  /* =========================
     2) 正确答案（32 音）
  ========================= */
  const target = [
    // A
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
    // B
    ["red","do"],["red","re"],["red","la"],["blue","re"],["blue","fa"],["red","la"],["blue","re"],["blue","fa"],
    // C
    ["green","si"],["red","re"],["red","so"],["blue","re"],["blue","fa"],["red","so"],["blue","re"],["blue","fa"],
    // D (=A)
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
  ];

  /* =========================
     3) 时间规则：仅要求相邻间隔 ≤ 2s
  ========================= */
  const MAX_GAP = 2.0; // 秒

  /* =========================
     4) WebAudio：更长、更“银色”
  ========================= */
  let audioCtx=null, audioEnabled=false;
  function ensureAudioCtx(){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!audioCtx) audioCtx = new AC();
    return audioCtx;
  }
  async function enableAudio(){
    const ctx = ensureAudioCtx();
    if(ctx.state==="suspended") await ctx.resume();
    audioEnabled = true;
  }
  function midiToFreq(m){ return 440*Math.pow(2,(m-69)/12); }

  // 更长：默认 1.2s
  function playTone(freq, duration=1.20){
    if(!audioEnabled || !audioCtx) return;
    const now = audioCtx.currentTime;

    const o1 = audioCtx.createOscillator();
    const o2 = audioCtx.createOscillator();
    const o3 = audioCtx.createOscillator();

    o1.type="sine";
    o2.type="triangle";
    o3.type="square";

    o1.frequency.setValueAtTime(freq, now);
    o2.frequency.setValueAtTime(freq*2, now);
    o3.frequency.setValueAtTime(freq*4, now);

    const g1 = audioCtx.createGain(); g1.gain.value = 1.0;
    const g2 = audioCtx.createGain(); g2.gain.value = 0.55;
    const g3 = audioCtx.createGain(); g3.gain.value = 0.07;

    const amp = audioCtx.createGain();
    amp.gain.setValueAtTime(0.0001, now);
    amp.gain.linearRampToValueAtTime(0.32, now + 0.015);
    amp.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    const lp = audioCtx.createBiquadFilter();
    lp.type="lowpass";
    lp.frequency.setValueAtTime(Math.min(freq*6, 9000), now);
    lp.Q.value = 0.85;

    o1.connect(g1); g1.connect(amp);
    o2.connect(g2); g2.connect(amp);
    o3.connect(g3); g3.connect(amp);

    amp.connect(lp);
    lp.connect(audioCtx.destination);

    o1.start(now); o2.start(now); o3.start(now);
    const stopAt = now + duration + 0.12;
    o1.stop(stopAt); o2.stop(stopAt); o3.stop(stopAt);
  }

  /* =========================
     5) 关键：用“色块区域”自动分割 16 个键边界
     - 不靠等分
     - 不靠 OCR
     - 通过像素“非白”密度找出每个彩色块的左右边界
  ========================= */
  const kbd = document.getElementById("kbd");
  const img = document.getElementById("kbdImg");
  const overlay = document.getElementById("overlay");
  const statusEl = document.getElementById("status");
  const audioBtn = document.getElementById("audioBtn");
  const resetBtn = document.getElementById("resetBtn");
  const debugBtn = document.getElementById("debugBtn");

  let debug=false;
  let boundaries=null; // 长度 17，图片像素坐标：0..iw
  let segBoxes=[];
  let flashEl=null;

  function getImageDrawRect(){
    const cr = kbd.getBoundingClientRect();
    const cw = cr.width, ch = cr.height;
    const iw = img.naturalWidth  || 1024;
    const ih = img.naturalHeight || 461;
    const scale = Math.min(cw/iw, ch/ih);
    const dw = iw*scale, dh = ih*scale;
    const dx = cr.left + (cw-dw)/2;
    const dy = cr.top  + (ch-dh)/2;
    return {dx,dy,dw,dh,iw,ih};
  }

  function buildOverlay(){
    overlay.innerHTML="";
    segBoxes=[];
    flashEl=null;

    if(boundaries){
      // 画每个段的盒子（debug 观察偏移）
      for(let i=0;i<16;i++){
        const box = document.createElement("div");
        box.className="segbox";
        overlay.appendChild(box);
        segBoxes.push(box);
      }
      // 闪烁条
      flashEl = document.createElement("div");
      flashEl.className="flash";
      overlay.appendChild(flashEl);
      layoutOverlay();
    }
  }

  function layoutOverlay(){
    if(!boundaries || segBoxes.length!==16) return;
    const r = getImageDrawRect();
    // boundaries 是原图像素坐标，转换到显示坐标（相对 overlay）
    // overlay 与 kbd 同尺寸，因此直接用显示宽 r.dw 并加上留边 (cw-dw)/2
    const cr = kbd.getBoundingClientRect();
    const leftPad = (cr.width - r.dw)/2;

    for(let i=0;i<16;i++){
      const x0 = boundaries[i]   / r.iw * r.dw + leftPad;
      const x1 = boundaries[i+1] / r.iw * r.dw + leftPad;
      const w  = Math.max(0, x1-x0);
      segBoxes[i].style.left = x0 + "px";
      segBoxes[i].style.width = w + "px";
    }
  }

  function setDebug(on){
    debug = on;
    document.body.classList.toggle("debug", debug);
    debugBtn.textContent = debug ? "Debug On" : "Debug";
  }

  function flashKey(idx){
    if(!boundaries || !flashEl) return;
    const r = getImageDrawRect();
    const cr = kbd.getBoundingClientRect();
    const leftPad = (cr.width - r.dw)/2;

    const x0 = boundaries[idx]   / r.iw * r.dw + leftPad;
    const x1 = boundaries[idx+1] / r.iw * r.dw + leftPad;
    flashEl.style.left = x0 + "px";
    flashEl.style.width = Math.max(6, x1-x0) + "px";
    flashEl.classList.add("on");
    setTimeout(()=>flashEl.classList.remove("on"), 90);
  }

  function fallbackEqualBoundaries(){
    const iw = img.naturalWidth || 1024;
    const bds=[0];
    for(let i=1;i<16;i++) bds.push(Math.round(iw*i/16));
    bds.push(iw);
    return bds;
  }

  function detectBoundariesByColorBlocks(){
    const iw = img.naturalWidth, ih = img.naturalHeight;
    if(!iw || !ih) return null;

    const canvas = document.createElement("canvas");
    canvas.width=iw; canvas.height=ih;
    const ctx = canvas.getContext("2d", { willReadFrequently:true });
    ctx.drawImage(img, 0, 0, iw, ih);

    // 取色块所在带状区域：在图片底部 82%~96% 高度范围（覆盖彩色标签块）
    const y0 = Math.floor(ih * 0.82);
    const y1 = Math.floor(ih * 0.96);
    const h  = Math.max(1, y1-y0);

    const data = ctx.getImageData(0, y0, iw, h).data;

    // 对每个 x 统计“非白像素数量”：
    // 白键区域接近白（RGB都高）；色块/文字/边框是非白
    const score = new Float32Array(iw);

    for(let x=0;x<iw;x++){
      let s=0;
      for(let y=0;y<h;y++){
        const i = (y*iw + x)*4;
        const r=data[i], g=data[i+1], b=data[i+2];
        // 判定“接近白”阈值：> 240 且三通道都高
        const isWhite = (r>240 && g>240 && b>240);
        if(!isWhite) s++;
      }
      score[x]=s;
    }

    // 平滑（滑动平均），减少文字导致的噪声
    const smooth = new Float32Array(iw);
    const W = 9; // 窗口半径
    for(let x=0;x<iw;x++){
      let sum=0, cnt=0;
      for(let k=-W;k<=W;k++){
        const xx=x+k;
        if(xx>=0 && xx<iw){ sum+=score[xx]; cnt++; }
      }
      smooth[x]=sum/cnt;
    }

    // 归一化阈值：色块区域应明显高于白键
    let maxv=0;
    for(let x=0;x<iw;x++) if(smooth[x]>maxv) maxv=smooth[x];
    if(maxv < h*0.10) return null;

    const thresh = maxv * 0.35; // 经验阈值：越小越“包容”
    const inBlock = new Array(iw).fill(false);
    for(let x=0;x<iw;x++){
      inBlock[x] = smooth[x] > thresh;
    }

    // 找连续的“在色块区域内”的段
    const runs=[];
    let s=null;
    for(let x=0;x<iw;x++){
      if(inBlock[x] && s===null) s=x;
      if(!inBlock[x] && s!==null){
        const e=x-1;
        if(e-s > 10) runs.push([s,e]);
        s=null;
      }
    }
    if(s!==null){
      const e=iw-1;
      if(e-s > 10) runs.push([s,e]);
    }

    // 理想情况下应找到 16 个色块段
    // 若找到更多/更少，尝试用“挑选最宽的16段”
    if(runs.length < 12) return null;

    runs.sort((a,b)=> (b[1]-b[0]) - (a[1]-a[0])); // 宽度降序
    const picked = runs.slice(0, 16).sort((a,b)=>a[0]-b[0]);

    if(picked.length !== 16) return null;

    // 生成边界：用每段的起点作为边界，最后加上最后段终点
    const bds = [];
    bds.push(picked[0][0]);

    for(let i=1;i<16;i++){
      // 边界取前一段终点与后一段起点的中点，更稳
      const prev = picked[i-1];
      const cur  = picked[i];
      const bd = Math.floor((prev[1] + cur[0]) / 2);
      bds.push(bd);
    }
    bds.push(picked[15][1]);

    // 强制把首尾扩展到 0..iw（点击更容错）
    bds[0] = 0;
    bds[16] = iw;

    // 单调性修正
    for(let i=1;i<bds.length;i++){
      if(bds[i] <= bds[i-1]) bds[i] = bds[i-1] + 1;
    }

    return bds;
  }

  function pointToKeyIndex(clientX, clientY){
    const r = getImageDrawRect();
    // 落在图像显示区域外直接忽略
    if(clientX < r.dx || clientX > r.dx + r.dw || clientY < r.dy || clientY > r.dy + r.dh) return null;

    // 只允许点下半部分（避免点到黑键）
    const yNat = (clientY - r.dy) / r.dh * r.ih;
    if(yNat < r.ih * 0.52) return null;

    const xNat = (clientX - r.dx) / r.dw * r.iw;

    const bds = boundaries || fallbackEqualBoundaries();
    // 二分查找区间
    let lo=0, hi=16;
    while(lo<hi){
      const mid=(lo+hi)>>1;
      if(xNat < bds[mid+1]) hi=mid;
      else lo=mid+1;
    }
    if(lo<0 || lo>15) return null;
    return lo;
  }

  /* =========================
     6) 判定逻辑：只要 gap ≤ 2s 且音正确
  ========================= */
  let step=0;
  let lastTime=null;

  function reset(msg="未开始"){
    step=0;
    lastTime=null;
    statusEl.textContent=msg;
    statusEl.style.color="#fff";
  }
  function fail(msg){
    reset("失败：" + msg + "（已重置）");
    statusEl.style.color="#ff6b6b";
  }

  function pressKey(idx){
    flashKey(idx);

    const k = KEYS[idx];
    if(audioEnabled) playTone(midiToFreq(k.m), 1.20);
    else {
      statusEl.textContent="请先点“启用声音”";
      statusEl.style.color="#ffd36b";
    }

    // 时间约束：相邻 ≤ 2 秒
    const now = performance.now()/1000;
    if(lastTime !== null){
      const gap = now - lastTime;
      if(gap > MAX_GAP){
        fail(`间隔超过 ${MAX_GAP}s`);
        return;
      }
    }
    lastTime = now;

    // 顺序判定
    if(step >= target.length) return;

    const [tc, tn] = target[step];
    const needIdx = keyIndex.get(`${tc}|${tn}`);
    if(needIdx === undefined){ fail("内部配置错误（目标键不存在）"); return; }

    if(idx !== needIdx){
      fail(`音符错误：应为 ${tc}${tn}`);
      return;
    }

    step++;
    if(step === target.length){
      statusEl.textContent="success";
      statusEl.style.color="#00ff99";
    } else {
      statusEl.textContent=`进度 ${step}/${target.length}`;
      statusEl.style.color="#fff";
    }
  }

  /* =========================
     7) 事件绑定
  ========================= */
  function handleDown(ev){
    ev.preventDefault();
    const pt = (ev.touches && ev.touches[0]) ? ev.touches[0] : ev;
    const idx = pointToKeyIndex(pt.clientX, pt.clientY);
    if(idx === null) return;
    pressKey(idx);
  }

  kbd.addEventListener("touchstart", handleDown, {passive:false});
  kbd.addEventListener("pointerdown", handleDown, {passive:false});
  kbd.addEventListener("mousedown", handleDown, {passive:false});
  document.addEventListener("dblclick", (e)=>e.preventDefault(), {passive:false});
  window.addEventListener("resize", ()=>layoutOverlay());

  /* =========================
     8) 按钮
  ========================= */
  audioBtn.addEventListener("click", async ()=>{
    try{
      await enableAudio();
      audioBtn.textContent="声音已启用";
      audioBtn.disabled=true;
      statusEl.textContent="声音已启用，开始弹奏";
      statusEl.style.color="#00ff99";
    }catch(e){
      statusEl.textContent="启用声音失败（请再点一次）";
      statusEl.style.color="#ff6b6b";
    }
  });

  resetBtn.addEventListener("click", ()=>reset("已重置"));

  debugBtn.addEventListener("click", ()=>{
    setDebug(!debug);
    buildOverlay();
  });

  /* =========================
     9) 图片加载 -> 自动识别边界（色块）
  ========================= */
  img.addEventListener("load", ()=>{
    boundaries = detectBoundariesByColorBlocks() || fallbackEqualBoundaries();
    buildOverlay();
    reset("未开始");
  });

  // 初始
  reset("未开始");
})();
</script>
</body>
</html>
