<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Piano Puzzle</title>

<style>
html,body{
  margin:0;background:#fff;color:#111;
  font-family:-apple-system,BlinkMacSystemFont,"PingFang SC","Microsoft YaHei",sans-serif;
  user-select:none;-webkit-tap-highlight-color:transparent;
}
.wrap{max-width:1100px;margin:0 auto;padding:6px 8px;box-sizing:border-box;}
.topbar{display:flex;gap:8px;align-items:center;justify-content:space-between;flex-wrap:wrap;margin:0 0 4px;}
.status{font-size:14px;min-height:18px;line-height:18px;flex:1 1 240px;margin:0;}
.btns{display:flex;gap:8px;flex:0 0 auto;}
button{border:none;border-radius:10px;background:#111;color:#fff;padding:8px 10px;font-size:14px;cursor:pointer;}
button:active{transform:translateY(1px)}
.ok{background:#12b76a;color:#052;font-weight:700}

/* 提示字小一点 */
.hint{font-size:12px;line-height:1.35;margin:0 0 6px;}
.small{font-size:11px;opacity:.75;margin-top:2px;line-height:1.25;}

.kbd{position:relative;width:100%;overflow:hidden;background:#fff;touch-action:none;margin:0;}
.kbd::before{content:"";display:block;padding-top:34%;}
.kbd-inner{position:absolute;inset:0;display:flex;align-items:flex-start;justify-content:center;}
#kbdImg{width:100%;height:100%;object-fit:contain;object-position:center top;display:block;pointer-events:none;background:#fff;}

.overlay{position:absolute;inset:0;pointer-events:none;}
.segbox{position:absolute;top:0;bottom:0;outline:1px solid rgba(0,160,90,.70);background:rgba(0,160,90,.06);display:none;}
.debug .segbox{display:block;}

@media (orientation: landscape){
  .wrap{padding:4px 8px;}
  .hint{margin-bottom:4px;}
  button{padding:7px 10px;}
  .kbd::before{padding-top:26%;}
}
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="status" id="status">未开始</div>
    <div class="btns">
      <button id="audioBtn" class="ok">启用声音</button>
      <button id="resetBtn">Reset</button>
      <button id="debugBtn">Debug</button>
    </div>
  </div>

  <div class="hint">
    建议横屏操作；相邻两次点击间隔 ≤ 5 秒（超时重置）。
    <div class="small">iPhone：需先点击“启用声音”。</div>
  </div>

  <div class="kbd" id="kbd">
    <div class="kbd-inner">
      <img id="kbdImg" src="./keyboard.png" alt="keyboard" />
    </div>
    <div class="overlay" id="overlay"></div>
  </div>
</div>

<script>
(() => {
  /* =========================
     固定：12 键；最左为 green si
  ========================= */
  const FIX_N = 12;
  const FIX_OFFSET = 2;   // green so(0), green la(1), green si(2)
  const MAX_GAP = 5.0;

  // 如果你仍觉得“整体偏 1px”，改这里：0 / +1 / -1
  const GLOBAL_NUDGE = 0;

  // Debug 绿线间隔略大：对分割线做轻微“向中间压缩”
  // 值 < 1 会压缩（间隔变小），值 > 1 会展开（间隔变大）
  // 你觉得还偏大：把它调更小一点（例如 0.9982）
  const BOUNDARY_SCALE = 0.9970;

  /* =========================
     16 键总模板（完整键盘）
  ========================= */
  const KEYS = [
    {c:"green",n:"so",m:55},
    {c:"green",n:"la",m:57},
    {c:"green",n:"si",m:59},
    {c:"red",n:"do",m:60},
    {c:"red",n:"re",m:62},
    {c:"red",n:"mi",m:64},
    {c:"red",n:"fa",m:65},
    {c:"red",n:"so",m:67},
    {c:"red",n:"la",m:69},
    {c:"red",n:"si",m:71},
    {c:"blue",n:"do",m:72},
    {c:"blue",n:"re",m:74},
    {c:"blue",n:"mi",m:76},
    {c:"blue",n:"fa",m:77},
    {c:"blue",n:"so",m:79},
    {c:"blue",n:"la",m:81},
  ];

  const target = [
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
    ["red","do"],["red","re"],["red","la"],["blue","re"],["blue","fa"],["red","la"],["blue","re"],["blue","fa"],
    ["green","si"],["red","re"],["red","so"],["blue","re"],["blue","fa"],["red","so"],["blue","re"],["blue","fa"],
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
  ];

  /* =========================
     WebAudio（简易钢琴味，稍长音）
  ========================= */
  let audioCtx=null, audioEnabled=false;
  function ensureAudioCtx(){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!audioCtx) audioCtx = new AC();
    return audioCtx;
  }
  async function enableAudio(){
    const ctx = ensureAudioCtx();
    if(ctx.state==="suspended") await ctx.resume();
    audioEnabled = true;
  }
  function midiToFreq(m){ return 440*Math.pow(2,(m-69)/12); }
  function playTone(freq, duration=1.25){
    if(!audioEnabled || !audioCtx) return;
    const now = audioCtx.currentTime;

    const o1=audioCtx.createOscillator(), o2=audioCtx.createOscillator(), o3=audioCtx.createOscillator();
    o1.type="sine"; o2.type="triangle"; o3.type="square";
    o1.frequency.setValueAtTime(freq, now);
    o2.frequency.setValueAtTime(freq*2, now);
    o3.frequency.setValueAtTime(freq*4, now);

    const g1=audioCtx.createGain(); g1.gain.value=1.0;
    const g2=audioCtx.createGain(); g2.gain.value=0.55;
    const g3=audioCtx.createGain(); g3.gain.value=0.06;

    const amp=audioCtx.createGain();
    amp.gain.setValueAtTime(0.0001, now);
    amp.gain.linearRampToValueAtTime(0.33, now+0.015);
    amp.gain.exponentialRampToValueAtTime(0.0001, now+duration);

    const lp=audioCtx.createBiquadFilter();
    lp.type="lowpass";
    lp.frequency.setValueAtTime(Math.min(freq*6, 9000), now);
    lp.Q.value=0.85;

    o1.connect(g1); g1.connect(amp);
    o2.connect(g2); g2.connect(amp);
    o3.connect(g3); g3.connect(amp);
    amp.connect(lp); lp.connect(audioCtx.destination);

    o1.start(now); o2.start(now); o3.start(now);
    const stopAt = now+duration+0.12;
    o1.stop(stopAt); o2.stop(stopAt); o3.stop(stopAt);
  }

  /* =========================
     DOM
  ========================= */
  const kbd=document.getElementById("kbd");
  const img=document.getElementById("kbdImg");
  const overlay=document.getElementById("overlay");
  const statusEl=document.getElementById("status");
  const audioBtn=document.getElementById("audioBtn");
  const resetBtn=document.getElementById("resetBtn");
  const debugBtn=document.getElementById("debugBtn");

  let boundaries=null; // length FIX_N+1
  let segBoxes=[];

  function getImageDrawRect(){
    const cr = kbd.getBoundingClientRect();
    const cw=cr.width, ch=cr.height;
    const iw=img.naturalWidth||1024, ih=img.naturalHeight||461;
    const scale=Math.min(cw/iw, ch/ih);
    const dw=iw*scale, dh=ih*scale;
    const dx=cr.left+(cw-dw)/2;
    const dy=cr.top +(ch-dh)/2;
    return {dx,dy,dw,dh,iw,ih,cw,ch};
  }

  function fallbackEqualBoundaries(n){
    const iw = img.naturalWidth || 1024;
    const bds=[0];
    for(let i=1;i<n;i++) bds.push(Math.round(iw*i/n));
    bds.push(iw);
    return bds;
  }

  /* =========================
     核心：检测黑竖分隔线
     - 先吸附到黑线带中心
     - 再做等间距线性拟合校正
     - 再小半径二次吸附
     - 最后对整体做轻微缩放（修正“间隔略大”）
  ========================= */
  function detectBoundaries12BySeparators(){
    const iw=img.naturalWidth, ih=img.naturalHeight;
    if(!iw||!ih) return null;

    const canvas=document.createElement("canvas");
    canvas.width=iw; canvas.height=ih;
    const ctx=canvas.getContext("2d",{willReadFrequently:true});
    ctx.drawImage(img,0,0,iw,ih);

    const y0=Math.floor(ih*0.66);
    const y1=Math.floor(ih*0.90);
    const h=Math.max(1,y1-y0);
    const data=ctx.getImageData(0,y0,iw,h).data;

    const raw=new Float32Array(iw);
    for(let x=0;x<iw;x++){
      let s=0;
      for(let y=0;y<h;y++){
        const i=(y*iw+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2];
        if(r<60 && g<60 && b<60) s++;
      }
      raw[x]=s;
    }

    const tmp=Array.from(raw).sort((a,b)=>a-b);
    const baseline=tmp[Math.floor(tmp.length*0.5)];
    for(let x=0;x<iw;x++) raw[x]=Math.max(0, raw[x]-baseline);

    const smooth=new Float32Array(iw);
    const W=5;
    let maxv=0;
    for(let x=0;x<iw;x++){
      let sum=0,cnt=0;
      for(let k=-W;k<=W;k++){
        const xx=x+k;
        if(xx>=0 && xx<iw){ sum+=raw[xx]; cnt++; }
      }
      const v=sum/cnt;
      smooth[x]=v;
      if(v>maxv) maxv=v;
    }
    if(maxv < h*0.08) return null;

    const thresh=maxv*0.45;
    const peaks=[];
    for(let x=2;x<iw-2;x++){
      const v=smooth[x];
      if(v<thresh) continue;
      if(v>=smooth[x-1] && v>=smooth[x+1] && v>=smooth[x-2] && v>=smooth[x+2]){
        peaks.push({x, v});
      }
    }
    if(peaks.length < 11) return null;

    peaks.sort((a,b)=>b.v-a.v);
    const need = FIX_N - 1; // 11
    const minDist = Math.floor(iw/(FIX_N*1.20));
    const chosen=[];
    for(const p of peaks){
      if(p.x < iw*0.02 || p.x > iw*0.98) continue;
      let ok=true;
      for(const q of chosen){
        if(Math.abs(p.x - q.x) < minDist){ ok=false; break; }
      }
      if(!ok) continue;
      chosen.push(p);
      if(chosen.length===need) break;
    }
    if(chosen.length!==need) return null;
    chosen.sort((a,b)=>a.x-b.x);

    function snapToDarkRunCenter(x0){
      const R = 10;
      const L = Math.max(2, x0 - R);
      const Rr = Math.min(iw - 3, x0 + R);

      let bestX=x0, bestV=-1;
      for(let x=L;x<=Rr;x++){
        const v=raw[x];
        if(v>bestV){ bestV=v; bestX=x; }
      }
      if(bestV<=0) return bestX;

      const th = bestV * 0.90;
      let a=bestX, b=bestX;
      while(a>L  && raw[a-1] >= th) a--;
      while(b<Rr && raw[b+1] >= th) b++;
      return Math.round((a+b)/2);
    }

    // 1) 初次吸附
    let refined = chosen.map(p => snapToDarkRunCenter(p.x));

    // 2) 等间距线性拟合（最小二乘） x ≈ a + k*d, k=1..11
    let sumk=0, sumx=0, sumkk=0, sumkx=0;
    for(let i=0;i<need;i++){
      const k=i+1;
      const x=refined[i];
      sumk += k;
      sumx += x;
      sumkk += k*k;
      sumkx += k*x;
    }
    const n=need;
    const denom = (n*sumkk - sumk*sumk) || 1;
    const d = (n*sumkx - sumk*sumx) / denom;
    const a0 = (sumx - d*sumk) / n;

    const fitted=[];
    for(let k=1;k<=need;k++){
      fitted.push(Math.round(a0 + d*k));
    }

    // 3) 小半径二次吸附
    function snapSmall(x0){
      const R = 4;
      const L = Math.max(2, x0 - R);
      const Rr = Math.min(iw - 3, x0 + R);

      let bestX=x0, bestV=-1;
      for(let x=L;x<=Rr;x++){
        const v=raw[x];
        if(v>bestV){ bestV=v; bestX=x; }
      }
      if(bestV<=0) return bestX;

      const th = bestV * 0.90;
      let a=bestX, b=bestX;
      while(a>L  && raw[a-1] >= th) a--;
      while(b<Rr && raw[b+1] >= th) b++;
      return Math.round((a+b)/2);
    }

    refined = fitted.map(x => snapSmall(x) + GLOBAL_NUDGE);

    // 4) 轻微缩放校正：向中心压缩/展开
    // 让“间隔略大”的绿线与黑线更贴合
    const center = iw * 0.5;
    refined = refined.map(x => Math.round(center + (x - center) * BOUNDARY_SCALE));

    const bds=[0, ...refined, iw];

    for(let i=1;i<bds.length;i++){
      if(bds[i]<=bds[i-1]) bds[i]=bds[i-1]+1;
    }
    return bds;
  }

  function buildOverlay(){
    overlay.innerHTML="";
    segBoxes=[];

    if(!boundaries) return;

    for(let i=0;i<FIX_N;i++){
      const box=document.createElement("div");
      box.className="segbox";
      overlay.appendChild(box);
      segBoxes.push(box);
    }

    layoutOverlay();
  }

  function layoutOverlay(){
    if(!boundaries || segBoxes.length!==FIX_N) return;
    const r = getImageDrawRect();
    const leftPad = (r.cw - r.dw)/2;

    for(let i=0;i<FIX_N;i++){
      const x0 = boundaries[i]   / r.iw * r.dw + leftPad;
      const x1 = boundaries[i+1] / r.iw * r.dw + leftPad;
      segBoxes[i].style.left = x0 + "px";
      segBoxes[i].style.width = Math.max(0, x1-x0) + "px";
    }
  }

  function pointToLocalIndex(clientX, clientY){
    const r = getImageDrawRect();
    if(clientX<r.dx || clientX>r.dx+r.dw || clientY<r.dy || clientY>r.dy+r.dh) return null;

    const yNat = (clientY-r.dy)/r.dh*r.ih;
    if(yNat < r.ih*0.52) return null;

    const xNat = (clientX-r.dx)/r.dw*r.iw;
    const bds = boundaries || fallbackEqualBoundaries(FIX_N);

    let lo=0, hi=FIX_N-1;
    while(lo<=hi){
      const mid=(lo+hi)>>1;
      if(xNat < bds[mid]) hi=mid-1;
      else if(xNat >= bds[mid+1]) lo=mid+1;
      else return mid;
    }
    return null;
  }

  /* =========================
     判定逻辑
  ========================= */
  let step=0;
  let lastTime=null;

  function reset(msg="未开始"){
    step=0; lastTime=null;
    statusEl.textContent=msg;
    statusEl.style.color="#111";
  }
  function fail(msg){
    reset("失败：" + msg + "（已重置）");
    statusEl.style.color="#b42318";
  }
  function timeoutReset(){
    reset("已超时，请重新完整弹奏。");
    statusEl.style.color="#b42318";
  }

  function pressLocal(localIdx){
    const globalIdx = FIX_OFFSET + localIdx;
    if(globalIdx < 0 || globalIdx >= 16) return;

    const key = KEYS[globalIdx];
    if(audioEnabled) playTone(midiToFreq(key.m), 1.25);

    const now = performance.now()/1000;
    if(lastTime !== null && (now-lastTime) > MAX_GAP){
      timeoutReset();
      return;
    }
    lastTime = now;

    if(step >= target.length) return;

    const [tc, tn] = target[step];
    const needIdx = KEYS.findIndex(k => k.c===tc && k.n===tn);
    if(needIdx < 0){ fail("内部配置错误"); return; }

    if(needIdx < FIX_OFFSET || needIdx >= FIX_OFFSET + FIX_N){
      fail("当前键盘图片缺少必要琴键");
      return;
    }

    if(globalIdx !== needIdx){
      // 简化错误提示
      fail("音符错误，请再弹一次。");
      return;
    }

    step++;
    if(step === target.length){
      statusEl.textContent="success";
      statusEl.style.color="#067647";
    } else {
      statusEl.textContent=`进度 ${step}/${target.length}`;
      statusEl.style.color="#111";
    }
  }

  /* =========================
     事件
  ========================= */
  let lastDownAt = 0;
  function handlePointerDown(ev){
    const t = performance.now();
    if(t - lastDownAt < 50) return;
    lastDownAt = t;

    ev.preventDefault();
    const localIdx = pointToLocalIndex(ev.clientX, ev.clientY);
    if(localIdx === null) return;
    pressLocal(localIdx);
  }
  kbd.addEventListener("pointerdown", handlePointerDown, {passive:false});
  window.addEventListener("resize", ()=>layoutOverlay());

  /* =========================
     按钮
  ========================= */
  audioBtn.addEventListener("click", async ()=>{
    try{
      await enableAudio();
      audioBtn.textContent="声音已启用";
      audioBtn.disabled=true;
      statusEl.textContent="声音已启用，开始弹奏";
      statusEl.style.color="#067647";
    }catch(e){
      statusEl.textContent="启用声音失败（请再点一次）";
      statusEl.style.color="#b42318";
    }
  });

  resetBtn.addEventListener("click", ()=>reset("已重置"));

  debugBtn.addEventListener("click", ()=>{
    const on = document.body.classList.toggle("debug");
    debugBtn.textContent = on ? "Debug On" : "Debug";
  });

  /* =========================
     图片加载 -> 一定生成 12 段
  ========================= */
  img.addEventListener("load", ()=>{
    boundaries = detectBoundaries12BySeparators();
    if(!boundaries || boundaries.length !== FIX_N+1){
      boundaries = fallbackEqualBoundaries(FIX_N);
    }
    buildOverlay();
    reset("未开始");
  });

  reset("未开始");
})();
</script>
</body>
</html>
