<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Piano Puzzle</title>

<style>
  html,body{
    margin:0;
    background:#fff;
    color:#111;
    font-family:-apple-system,BlinkMacSystemFont,"PingFang SC","Microsoft YaHei",sans-serif;
    user-select:none;
    -webkit-tap-highlight-color:transparent;
  }

  .wrap{
    max-width:1100px;
    margin:0 auto;
    padding:6px 8px;
    box-sizing:border-box;
  }

  .topbar{
    display:flex;
    gap:8px;
    align-items:center;
    justify-content:space-between;
    flex-wrap:wrap;
    margin:0 0 4px;
  }

  .status{
    font-size:14px;
    min-height:18px;
    line-height:18px;
    flex:1 1 240px;
    margin:0;
  }

  .btns{display:flex;gap:8px;flex:0 0 auto;}

  button{
    border:none;
    border-radius:10px;
    background:#111;
    color:#fff;
    padding:8px 10px;
    font-size:14px;
    cursor:pointer;
  }
  button:active{transform:translateY(1px)}
  .ok{background:#12b76a;color:#052;font-weight:700}

  .hint{
    font-size:14px;
    line-height:1.35;
    margin:0 0 6px;
  }
  .small{
    font-size:12px;
    opacity:.75;
    margin-top:2px;
    line-height:1.25;
  }

  .kbd{
    position:relative;
    width:100%;
    overflow:hidden;
    background:#fff;
    box-shadow:none;
    touch-action:none;
    margin:0;
  }

  .kbd::before{
    content:"";
    display:block;
    padding-top:34%;
  }

  .kbd-inner{
    position:absolute;
    inset:0;
    display:flex;
    align-items:flex-start;
    justify-content:center;
  }

  #kbdImg{
    width:100%;
    height:100%;
    object-fit:contain;
    object-position:center top;
    display:block;
    pointer-events:none;
    background:#fff;
  }

  .overlay{position:absolute;inset:0;pointer-events:none;}
  .segbox{
    position:absolute;top:0;bottom:0;
    outline:1px solid rgba(0,150,80,.55);
    background:rgba(0,150,80,.06);
    display:none;
  }
  .debug .segbox{display:block;}

  .flash{
    position:absolute;
    top:56%;
    height:44%;
    background:rgba(0,0,0,0.10);
    border-radius:10px;
    opacity:0;
    transition:opacity 70ms linear;
  }
  .flash.on{opacity:1;}

  @media (orientation: landscape){
    .wrap{padding:4px 8px;}
    .topbar{margin-bottom:3px;}
    .hint{margin-bottom:4px;}
    button{padding:7px 10px;}
    .kbd::before{padding-top:26%;}
  }
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="status" id="status">未开始</div>
    <div class="btns">
      <button id="audioBtn" class="ok">启用声音</button>
      <button id="resetBtn">Reset</button>
      <button id="debugBtn">Debug</button>
    </div>
  </div>

  <div class="hint">
    建议横屏操作。只要按对音符顺序即可；相邻两次点击间隔必须 ≤ 5 秒（超时则重置）。
    <div class="small">iPhone：先点一次“启用声音”。</div>
  </div>

  <div class="kbd" id="kbd">
    <div class="kbd-inner">
      <img id="kbdImg" src="./keyboard.png" alt="keyboard" />
    </div>
    <div class="overlay" id="overlay"></div>
  </div>
</div>

<script>
(() => {
  /* =========================
     1) 16 键总模板（完整键盘）
  ========================= */
  const KEYS = [
    {c:"green",n:"so",m:55},
    {c:"green",n:"la",m:57},
    {c:"green",n:"si",m:59},

    {c:"red",n:"do",m:60},
    {c:"red",n:"re",m:62},
    {c:"red",n:"mi",m:64},
    {c:"red",n:"fa",m:65},
    {c:"red",n:"so",m:67},
    {c:"red",n:"la",m:69},
    {c:"red",n:"si",m:71},

    {c:"blue",n:"do",m:72},
    {c:"blue",n:"re",m:74},
    {c:"blue",n:"mi",m:76},
    {c:"blue",n:"fa",m:77},
    {c:"blue",n:"so",m:79},
    {c:"blue",n:"la",m:81},
  ];
  const CANON_COLORS = KEYS.map(k => k.c);

  /* =========================
     2) 正确答案（32 音）——仍按“完整 16 键模板”描述
     （短键盘图只要包含这些音对应的键，就能弹）
  ========================= */
  const target = [
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
    ["red","do"],["red","re"],["red","la"],["blue","re"],["blue","fa"],["red","la"],["blue","re"],["blue","fa"],
    ["green","si"],["red","re"],["red","so"],["blue","re"],["blue","fa"],["red","so"],["blue","re"],["blue","fa"],
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
  ];

  /* =========================
     3) 时间规则
  ========================= */
  const MAX_GAP = 5.0;

  /* =========================
     4) WebAudio
  ========================= */
  let audioCtx=null, audioEnabled=false;
  function ensureAudioCtx(){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(!audioCtx) audioCtx = new AC();
    return audioCtx;
  }
  async function enableAudio(){
    const ctx = ensureAudioCtx();
    if(ctx.state==="suspended") await ctx.resume();
    audioEnabled = true;
  }
  function midiToFreq(m){ return 440*Math.pow(2,(m-69)/12); }
  function playTone(freq, duration=1.20){
    if(!audioEnabled || !audioCtx) return;
    const now = audioCtx.currentTime;

    const o1=audioCtx.createOscillator(), o2=audioCtx.createOscillator(), o3=audioCtx.createOscillator();
    o1.type="sine"; o2.type="triangle"; o3.type="square";
    o1.frequency.setValueAtTime(freq, now);
    o2.frequency.setValueAtTime(freq*2, now);
    o3.frequency.setValueAtTime(freq*4, now);

    const g1=audioCtx.createGain(); g1.gain.value=1.0;
    const g2=audioCtx.createGain(); g2.gain.value=0.55;
    const g3=audioCtx.createGain(); g3.gain.value=0.07;

    const amp=audioCtx.createGain();
    amp.gain.setValueAtTime(0.0001, now);
    amp.gain.linearRampToValueAtTime(0.32, now+0.015);
    amp.gain.exponentialRampToValueAtTime(0.0001, now+duration);

    const lp=audioCtx.createBiquadFilter();
    lp.type="lowpass";
    lp.frequency.setValueAtTime(Math.min(freq*6, 9000), now);
    lp.Q.value=0.85;

    o1.connect(g1); g1.connect(amp);
    o2.connect(g2); g2.connect(amp);
    o3.connect(g3); g3.connect(amp);
    amp.connect(lp); lp.connect(audioCtx.destination);

    o1.start(now); o2.start(now); o3.start(now);
    const stopAt = now+duration+0.12;
    o1.stop(stopAt); o2.stop(stopAt); o3.stop(stopAt);
  }

  /* =========================
     5) DOM
  ========================= */
  const kbd=document.getElementById("kbd");
  const img=document.getElementById("kbdImg");
  const overlay=document.getElementById("overlay");
  const statusEl=document.getElementById("status");
  const audioBtn=document.getElementById("audioBtn");
  const resetBtn=document.getElementById("resetBtn");
  const debugBtn=document.getElementById("debugBtn");

  let debug=false;

  // 关键：短键盘图下的“局部键盘”
  let boundaries=null;          // length (N+1)
  let visibleN=16;              // N
  let visibleOffset=0;          // offset in 16-key template

  let segBoxes=[];
  let flashEl=null;

  function getImageDrawRect(){
    const cr = kbd.getBoundingClientRect();
    const cw=cr.width, ch=cr.height;
    const iw=img.naturalWidth||1024, ih=img.naturalHeight||461;
    const scale=Math.min(cw/iw, ch/ih);
    const dw=iw*scale, dh=ih*scale;
    const dx=cr.left+(cw-dw)/2;
    const dy=cr.top +(ch-dh)/2;
    return {dx,dy,dw,dh,iw,ih,cw,ch};
  }

  function fallbackEqualBoundaries(n=16){
    const iw = img.naturalWidth || 1024;
    const bds=[0];
    for(let i=1;i<n;i++) bds.push(Math.round(iw*i/n));
    bds.push(iw);
    return bds;
  }

  function detectBoundariesByColorBlocks(){
    const iw=img.naturalWidth, ih=img.naturalHeight;
    if(!iw||!ih) return null;

    const canvas=document.createElement("canvas");
    canvas.width=iw; canvas.height=ih;
    const ctx=canvas.getContext("2d",{willReadFrequently:true});
    ctx.drawImage(img,0,0,iw,ih);

    // 色块带：底部 82%~96%
    const y0=Math.floor(ih*0.82), y1=Math.floor(ih*0.96);
    const h=Math.max(1,y1-y0);
    const data=ctx.getImageData(0,y0,iw,h).data;

    const score=new Float32Array(iw);
    for(let x=0;x<iw;x++){
      let s=0;
      for(let y=0;y<h;y++){
        const i=(y*iw+x)*4;
        const r=data[i], g=data[i+1], b=data[i+2];
        const isWhite=(r>240 && g>240 && b>240);
        if(!isWhite) s++;
      }
      score[x]=s;
    }

    // smooth
    const smooth=new Float32Array(iw);
    const W=9;
    let maxv=0;
    for(let x=0;x<iw;x++){
      let sum=0,cnt=0;
      for(let k=-W;k<=W;k++){
        const xx=x+k;
        if(xx>=0&&xx<iw){sum+=score[xx];cnt++;}
      }
      smooth[x]=sum/cnt;
      if(smooth[x]>maxv) maxv=smooth[x];
    }
    if(maxv < h*0.10) return null;

    const thresh=maxv*0.35;
    const inBlock=new Array(iw).fill(false);
    for(let x=0;x<iw;x++) inBlock[x]=smooth[x]>thresh;

    // 连续段
    const runs=[];
    let s=null;
    for(let x=0;x<iw;x++){
      if(inBlock[x] && s===null) s=x;
      if(!inBlock[x] && s!==null){
        const e=x-1;
        if(e-s>10) runs.push([s,e]);
        s=null;
      }
    }
    if(s!==null){
      const e=iw-1;
      if(e-s>10) runs.push([s,e]);
    }
    if(runs.length < 6) return null;

    // 这里不再强行取 16 个；取“足够宽”的段作为色块
    runs.sort((a,b)=>a[0]-b[0]);

    // 合并/过滤：避免文字噪声形成小段
    const filtered=[];
    for(const [a,b] of runs){
      if(b-a >= 18) filtered.push([a,b]);
    }
    if(filtered.length < 6) return null;

    // 生成边界（N 段 -> N+1 边界）
    const N = filtered.length;
    const bds=[];
    bds.push(0);
    for(let i=1;i<N;i++){
      const prev=filtered[i-1], cur=filtered[i];
      bds.push(Math.floor((prev[1]+cur[0])/2));
    }
    bds.push(iw);

    // 单调修正
    for(let i=1;i<bds.length;i++){
      if(bds[i]<=bds[i-1]) bds[i]=bds[i-1]+1;
    }

    return { bds, N, canvasCtx: ctx, iw, ih };
  }

  // 采样每个色块的颜色，粗分类为 green/red/blue
  function classifyBlockColors(ctx, bds, N, iw, ih){
    const y = Math.floor(ih*0.90);
    const colors = [];
    for(let i=0;i<N;i++){
      const x0=bds[i], x1=bds[i+1];
      const xc=Math.floor((x0+x1)/2);

      // 采样 9x9
      let rs=0, gs=0, bs=0, cnt=0;
      for(let dy=-4;dy<=4;dy++){
        for(let dx=-4;dx<=4;dx++){
          const xx=Math.min(iw-1, Math.max(0, xc+dx));
          const yy=Math.min(ih-1, Math.max(0, y+dy));
          const p = ctx.getImageData(xx,yy,1,1).data;
          rs+=p[0]; gs+=p[1]; bs+=p[2]; cnt++;
        }
      }
      const r=rs/cnt, g=gs/cnt, b=bs/cnt;

      // 简单阈值分类：只需要区分绿/红/蓝
      let c="unknown";
      if(g > r+25 && g > b+25) c="green";
      else if(r > g+25 && r > b+25) c="red";
      else if(b > r+25 && b > g+25) c="blue";
      else {
        // 若太灰，尝试用最大通道判定
        const m=Math.max(r,g,b);
        if(m===g) c="green";
        else if(m===r) c="red";
        else c="blue";
      }
      colors.push(c);
    }
    return colors;
  }

  // 用颜色序列在完整 16 键颜色模板中匹配，得到 offset
  function inferOffsetByColors(observed){
    const N = observed.length;
    let bestOff=0, bestScore=-1;

    for(let off=0; off<=16-N; off++){
      let s=0;
      for(let i=0;i<N;i++){
        if(observed[i] === CANON_COLORS[off+i]) s++;
      }
      if(s>bestScore){bestScore=s; bestOff=off;}
    }

    // 若匹配度太低，兜底为 0
    if(bestScore < Math.floor(N*0.6)) return 0;
    return bestOff;
  }

  function buildOverlay(){
    overlay.innerHTML="";
    segBoxes=[];
    flashEl=null;

    if(!boundaries) return;

    for(let i=0;i<visibleN;i++){
      const box=document.createElement("div");
      box.className="segbox";
      overlay.appendChild(box);
      segBoxes.push(box);
    }
    flashEl=document.createElement("div");
    flashEl.className="flash";
    overlay.appendChild(flashEl);

    layoutOverlay();
  }

  function layoutOverlay(){
    if(!boundaries || segBoxes.length!==visibleN) return;
    const r = getImageDrawRect();
    const leftPad = (r.cw - r.dw)/2;

    for(let i=0;i<visibleN;i++){
      const x0 = boundaries[i]   / r.iw * r.dw + leftPad;
      const x1 = boundaries[i+1] / r.iw * r.dw + leftPad;
      segBoxes[i].style.left = x0 + "px";
      segBoxes[i].style.width = Math.max(0, x1-x0) + "px";
    }
  }

  function flashKey(localIdx){
    if(!flashEl || !boundaries) return;
    const r = getImageDrawRect();
    const leftPad = (r.cw - r.dw)/2;

    const x0 = boundaries[localIdx]   / r.iw * r.dw + leftPad;
    const x1 = boundaries[localIdx+1] / r.iw * r.dw + leftPad;
    flashEl.style.left = x0 + "px";
    flashEl.style.width = Math.max(6, x1-x0) + "px";
    flashEl.classList.add("on");
    setTimeout(()=>flashEl.classList.remove("on"), 90);
  }

  function pointToLocalIndex(clientX, clientY){
    const r = getImageDrawRect();
    if(clientX<r.dx || clientX>r.dx+r.dw || clientY<r.dy || clientY>r.dy+r.dh) return null;

    const yNat = (clientY-r.dy)/r.dh*r.ih;
    if(yNat < r.ih*0.52) return null;

    const xNat = (clientX-r.dx)/r.dw*r.iw;
    const bds = boundaries || fallbackEqualBoundaries(visibleN);

    let lo=0, hi=visibleN-1;
    while(lo<=hi){
      const mid=(lo+hi)>>1;
      if(xNat < bds[mid]) hi=mid-1;
      else if(xNat >= bds[mid+1]) lo=mid+1;
      else return mid;
    }
    return null;
  }

  /* =========================
     6) 判定逻辑（globalIndex = offset + localIndex）
  ========================= */
  let step=0;
  let lastTime=null;

  function reset(msg="未开始"){
    step=0; lastTime=null;
    statusEl.textContent=msg;
    statusEl.style.color="#111";
  }
  function fail(msg){
    reset("失败：" + msg + "（已重置）");
    statusEl.style.color="#b42318";
  }
  function timeoutReset(){
    reset("已超时，请重新完整弹奏。");
    statusEl.style.color="#b42318";
  }

  function pressLocal(localIdx){
    const globalIdx = visibleOffset + localIdx;
    if(globalIdx < 0 || globalIdx >= 16) return;

    flashKey(localIdx);

    const key = KEYS[globalIdx];
    if(audioEnabled) playTone(midiToFreq(key.m), 1.20);

    const now = performance.now()/1000;
    if(lastTime !== null && (now-lastTime) > MAX_GAP){
      timeoutReset();
      return;
    }
    lastTime = now;

    // 目标音符转成 globalIdx
    if(step >= target.length) return;
    const [tc, tn] = target[step];

    const needIdx = KEYS.findIndex(k => k.c===tc && k.n===tn);
    if(needIdx < 0){ fail("内部配置错误"); return; }

    // 若目标键不在当前可见键盘范围内，直接提示（避免玩家无解）
    if(needIdx < visibleOffset || needIdx >= visibleOffset + visibleN){
      fail("当前键盘图片缺少必要琴键，请换回包含该音的键盘图");
      return;
    }

    if(globalIdx !== needIdx){
      fail(`音符错误：应为 ${tc}${tn}`);
      return;
    }

    step++;
    if(step === target.length){
      statusEl.textContent="success";
      statusEl.style.color="#067647";
    } else {
      statusEl.textContent=`进度 ${step}/${target.length}`;
      statusEl.style.color="#111";
    }
  }

  /* =========================
     7) 事件：pointerdown + 去抖
  ========================= */
  let lastDownAt = 0;
  function handlePointerDown(ev){
    const t = performance.now();
    if(t - lastDownAt < 50) return;
    lastDownAt = t;

    ev.preventDefault();
    const localIdx = pointToLocalIndex(ev.clientX, ev.clientY);
    if(localIdx === null) return;
    pressLocal(localIdx);
  }
  kbd.addEventListener("pointerdown", handlePointerDown, {passive:false});
  window.addEventListener("resize", ()=>layoutOverlay());

  /* =========================
     8) 按钮
  ========================= */
  audioBtn.addEventListener("click", async ()=>{
    try{
      await enableAudio();
      audioBtn.textContent="声音已启用";
      audioBtn.disabled=true;
      statusEl.textContent="声音已启用，开始弹奏";
      statusEl.style.color="#067647";
    }catch(e){
      statusEl.textContent="启用声音失败（请再点一次）";
      statusEl.style.color="#b42318";
    }
  });

  resetBtn.addEventListener("click", ()=>reset("已重置"));

  debugBtn.addEventListener("click", ()=>{
    debug = !debug;
    document.body.classList.toggle("debug", debug);
    debugBtn.textContent = debug ? "Debug On" : "Debug";
  });

  /* =========================
     9) 图片加载 -> 自动识别 N + offset
  ========================= */
  img.addEventListener("load", ()=>{
    const det = detectBoundariesByColorBlocks();

    if(!det){
      // 兜底：当成 16 键完整图
      visibleN = 16;
      visibleOffset = 0;
      boundaries = fallbackEqualBoundaries(16);
      buildOverlay();
      reset("未开始");
      return;
    }

    const { bds, N, canvasCtx, iw, ih } = det;

    // 识别可见键数量
    visibleN = Math.min(16, Math.max(6, N));
    boundaries = bds;

    // 识别颜色序列并推 offset
    const observedColors = classifyBlockColors(canvasCtx, bds, visibleN, iw, ih);
    visibleOffset = inferOffsetByColors(observedColors);

    // 可选：在状态栏给你看一下识别结果（你调试用）
    statusEl.textContent = `未开始（识别到 ${visibleN} 键，offset=${visibleOffset}）`;
    statusEl.style.color="#111";

    buildOverlay();
    step=0; lastTime=null;
  });

  reset("未开始");
})();
</script>
</body>
</html>
