<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Piano Puzzle</title>

<style>
  html,body{
    margin:0;
    background:#000;
    color:#fff;
    font-family:-apple-system,BlinkMacSystemFont,"PingFang SC","Microsoft YaHei",sans-serif;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
  }
  .wrap{
    max-width:1100px;
    margin:0 auto;
    padding:14px;
    box-sizing:border-box;
  }
  .topbar{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:space-between;
    flex-wrap:wrap;
    margin-bottom:10px;
  }
  .status{
    font-size:14px;
    min-height:22px;
    flex:1 1 240px;
    opacity:.95;
  }
  .btns{
    display:flex;
    gap:10px;
    flex:0 0 auto;
  }
  button{
    border:none;
    border-radius:10px;
    background:#222;
    color:#fff;
    padding:10px 14px;
    font-size:14px;
  }
  button:active{transform:translateY(1px)}
  .ok{background:#0b5;color:#021;font-weight:700}
  .hint{
    font-size:14px;
    opacity:.9;
    line-height:1.5;
    margin:6px 0 10px;
  }
  .small{opacity:.75;font-size:12px;margin-top:4px;line-height:1.4;}

  .kbd{
    position:relative;
    width:100%;
    border-radius:12px;
    overflow:hidden;
    box-shadow:0 10px 30px rgba(0,0,0,.6);
    background:#111;
  }
  /* 保持键盘容器比例：你的图约 1024x461 */
  .kbd::before{content:"";display:block;padding-top:45.1%;}
  .kbd-inner{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
  }
  /* 关键：用 img + contain，杜绝裁切造成的坐标错位 */
  #kbdImg{
    width:100%;
    height:100%;
    object-fit:contain;
    object-position:center;
    display:block;
    pointer-events:none; /* 点击由容器接管 */
  }

  /* 可选的按键反馈：在图上叠一层轻微闪烁 */
  .flash{
    position:absolute;
    inset:0;
    pointer-events:none;
  }
  .flash-bar{
    position:absolute;
    top:56%;
    height:44%;
    border-radius:10px;
    background:rgba(255,255,255,0.10);
    opacity:0;
    transition:opacity 70ms linear;
  }
  .flash-bar.on{opacity:1;}
</style>
</head>

<body>
<div class="wrap">
  <div class="topbar">
    <div class="status" id="status">未开始</div>
    <div class="btns">
      <button id="audioBtn" class="ok">启用声音</button>
      <button id="resetBtn">Reset</button>
    </div>
  </div>

  <div class="hint">
    按正确顺序弹奏旋律，并保持节奏均匀（第 1–2 音间隔作为基准）。节奏判定已放宽。
    <div class="small">iPhone：先点一次“启用声音”。</div>
  </div>

  <div class="kbd" id="kbd">
    <div class="kbd-inner">
      <img id="kbdImg" src="./keyboard.png" alt="keyboard" />
    </div>
    <div class="flash" id="flash"></div>
  </div>
</div>

<script>
(() => {
  /* =========================
     1) 键位定义（16 个白键）
     左绿 3 | 中红 7 | 右蓝 6
     红 do = C4 (60)
  ========================= */
  const KEYS = [
    {c:"green",n:"so",m:55},
    {c:"green",n:"la",m:57},
    {c:"green",n:"si",m:59},

    {c:"red",n:"do",m:60},
    {c:"red",n:"re",m:62},
    {c:"red",n:"mi",m:64},
    {c:"red",n:"fa",m:65},
    {c:"red",n:"so",m:67},
    {c:"red",n:"la",m:69},
    {c:"red",n:"si",m:71},

    {c:"blue",n:"do",m:72},
    {c:"blue",n:"re",m:74},
    {c:"blue",n:"mi",m:76},
    {c:"blue",n:"fa",m:77},
    {c:"blue",n:"so",m:79},
    {c:"blue",n:"la",m:81},
  ];

  const keyIndex = new Map();
  KEYS.forEach((k,i)=> keyIndex.set(`${k.c}|${k.n}`, i));

  /* =========================
     2) 正确答案（32 音）
  ========================= */
  const target = [
    // A
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
    // B
    ["red","do"],["red","re"],["red","la"],["blue","re"],["blue","fa"],["red","la"],["blue","re"],["blue","fa"],
    // C
    ["green","si"],["red","re"],["red","so"],["blue","re"],["blue","fa"],["red","so"],["blue","re"],["blue","fa"],
    // D (=A)
    ["red","do"],["red","mi"],["red","so"],["blue","do"],["blue","mi"],["red","so"],["blue","do"],["blue","mi"],
  ];

  /* =========================
     3) 节奏判定（更宽松）
  ========================= */
  const ABS_TOL = 0.16;   // 160ms（更宽松）
  const REL_TOL = 0.35;   // 35%
  const DT_MIN  = 0.12;
  const DT_MAX  = 1.80;

  function tolFor(dt0){ return Math.max(ABS_TOL, dt0 * REL_TOL); }

  /* =========================
     4) WebAudio：银色 / 明亮钢琴感（更长音）
  ========================= */
  let audioCtx = null;
  let audioEnabled = false;

  function ensureAudioCtx(){
    const AC = window.AudioContext || window.webkitAudioContext;
    if (!audioCtx) audioCtx = new AC();
    return audioCtx;
  }

  async function enableAudio(){
    const ctx = ensureAudioCtx();
    if (ctx.state === "suspended") await ctx.resume();
    audioEnabled = true;
  }

  function midiToFreq(m){ return 440 * Math.pow(2, (m - 69) / 12); }

  // 更长、更“按键感”的银音色：默认约 0.65s
  function playTone(freq, duration = 0.65){
    if (!audioEnabled || !audioCtx) return;

    const now = audioCtx.currentTime;

    const o1 = audioCtx.createOscillator(); // 基音
    const o2 = audioCtx.createOscillator(); // 泛音
    const o3 = audioCtx.createOscillator(); // 轻微击弦亮度

    o1.type = "sine";
    o2.type = "triangle";
    o3.type = "square";

    o1.frequency.setValueAtTime(freq, now);
    o2.frequency.setValueAtTime(freq * 2, now);
    o3.frequency.setValueAtTime(freq * 4, now);

    // 让 o3 很轻，避免刺耳
    const mix = audioCtx.createGain();
    const mix2 = audioCtx.createGain();
    const mix3 = audioCtx.createGain();
    mix.gain.value  = 1.00;
    mix2.gain.value = 0.55;
    mix3.gain.value = 0.10;

    const g = audioCtx.createGain();
    // attack + 较慢 decay（更长延音）
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.32, now + 0.015);
    g.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    const f = audioCtx.createBiquadFilter();
    f.type = "lowpass";
    f.frequency.setValueAtTime(Math.min(freq * 6, 10000), now);
    f.Q.value = 0.8;

    o1.connect(mix); mix.connect(g);
    o2.connect(mix2); mix2.connect(g);
    o3.connect(mix3); mix3.connect(g);

    g.connect(f);
    f.connect(audioCtx.destination);

    o1.start(now); o2.start(now); o3.start(now);
    const stopAt = now + duration + 0.08;
    o1.stop(stopAt); o2.stop(stopAt); o3.stop(stopAt);
  }

  /* =========================
     5) 关键：点击坐标映射到“实际显示的图像区域”
     - img 使用 contain 时，左右/上下可能留黑边
     - 必须把触摸点投影到图像真实显示矩形，否则会偏
  ========================= */
  const kbd = document.getElementById("kbd");
  const img = document.getElementById("kbdImg");
  const statusEl = document.getElementById("status");
  const audioBtn = document.getElementById("audioBtn");
  const resetBtn = document.getElementById("resetBtn");
  const flash = document.getElementById("flash");

  // 按键反馈条（仍在底部区域闪一下），按 16 键分段
  const flashBars = [];
  function buildFlashBars(){
    flash.innerHTML = "";
    flashBars.length = 0;

    for(let i=0;i<16;i++){
      const d = document.createElement("div");
      d.className = "flash-bar";
      d.style.left = (i * 100 / 16) + "%";
      d.style.width = (100 / 16) + "%";
      flash.appendChild(d);
      flashBars.push(d);
    }
  }
  buildFlashBars();

  function flashKey(i){
    const d = flashBars[i];
    if(!d) return;
    d.classList.add("on");
    setTimeout(()=>d.classList.remove("on"), 90);
  }

  function getImageDrawRect(){
    // 容器内容区
    const cr = kbd.getBoundingClientRect();
    const cw = cr.width;
    const ch = cr.height;

    // 图片原始宽高（加载后可得）
    const iw = img.naturalWidth || 1024;
    const ih = img.naturalHeight || 461;

    // contain：以较小缩放比适配
    const scale = Math.min(cw / iw, ch / ih);
    const dw = iw * scale;
    const dh = ih * scale;

    const dx = cr.left + (cw - dw) / 2;
    const dy = cr.top  + (ch - dh) / 2;

    return {dx, dy, dw, dh};
  }

  function pointToKeyIndex(clientX, clientY){
    const r = getImageDrawRect();

    // 若点在留黑边区域，直接判无效（避免误触）
    if (clientX < r.dx || clientX > r.dx + r.dw || clientY < r.dy || clientY > r.dy + r.dh) {
      return null;
    }

    const x = (clientX - r.dx) / r.dw; // 0..1 在图像内
    // 这里按 16 等分映射键位：由于图像不裁切，等分会和视觉一致得多
    let idx = Math.floor(x * 16);
    if (idx < 0) idx = 0;
    if (idx > 15) idx = 15;
    return idx;
  }

  /* =========================
     6) 判定逻辑（音符 + 节奏）
  ========================= */
  let step = 0;
  let t1=null, t2=null, dt0=null, last=null;

  function reset(msg="未开始"){
    step=0; t1=t2=dt0=last=null;
    statusEl.textContent = msg;
    statusEl.style.color = "#fff";
  }

  function fail(msg){
    reset("失败：" + msg + "（已重置）");
    statusEl.style.color = "#ff6b6b";
  }

  function pressKey(i){
    flashKey(i);

    const k = KEYS[i];
    if (audioEnabled) playTone(midiToFreq(k.m), 0.65);
    else {
      statusEl.textContent = "请先点“启用声音”";
      statusEl.style.color = "#ffd36b";
    }

    if (step >= target.length) return;

    const [tc, tn] = target[step];
    const needIdx = keyIndex.get(`${tc}|${tn}`);
    if (needIdx === undefined) { fail("内部配置错误（目标键不存在）"); return; }

    if (i !== needIdx){
      fail(`音符错误：应为 ${tc}${tn}`);
      return;
    }

    const now = performance.now() / 1000;

    if (step === 0){
      t1 = now; last = now; step++;
      statusEl.textContent = `进度 ${step}/${target.length}（等待建立基准间隔）`;
      statusEl.style.color = "#fff";
      return;
    }

    if (step === 1){
      t2 = now; dt0 = t2 - t1;
      if (dt0 < DT_MIN || dt0 > DT_MAX){
        fail(`第1-2音间隔 dt0=${dt0.toFixed(3)}s 不合理`);
        return;
      }
      last = now; step++;
      statusEl.textContent = `进度 ${step}/${target.length}（dt0=${dt0.toFixed(3)}s，容差±${tolFor(dt0).toFixed(3)}s）`;
      statusEl.style.color = "#fff";
      return;
    }

    const dt = now - last;
    const tol = tolFor(dt0);
    if (Math.abs(dt - dt0) > tol){
      fail(`节奏不均匀：dt=${dt.toFixed(3)}s，dt0=${dt0.toFixed(3)}s（容差±${tol.toFixed(3)}s）`);
      return;
    }

    last = now; step++;

    if (step === target.length){
      statusEl.textContent = "success";
      statusEl.style.color = "#00ff99";
    } else {
      statusEl.textContent = `进度 ${step}/${target.length}（dt0=${dt0.toFixed(3)}s，容差±${tolFor(dt0).toFixed(3)}s）`;
      statusEl.style.color = "#fff";
    }
  }

  /* =========================
     7) 事件：统一在容器上捕获点击，做坐标映射
  ========================= */
  function handleDown(ev){
    ev.preventDefault();

    const pt = (ev.touches && ev.touches[0]) ? ev.touches[0] : ev;
    const idx = pointToKeyIndex(pt.clientX, pt.clientY);
    if (idx === null) return; // 点在留边上不算

    pressKey(idx);
  }

  // iOS 上用 touchstart 最稳，同时也支持 pointer/mouse
  kbd.addEventListener("touchstart", handleDown, {passive:false});
  kbd.addEventListener("pointerdown", handleDown, {passive:false});
  kbd.addEventListener("mousedown", handleDown, {passive:false});

  // 防止双击缩放
  document.addEventListener("dblclick", (e)=>e.preventDefault(), {passive:false});

  /* =========================
     8) 按钮
  ========================= */
  audioBtn.addEventListener("click", async () => {
    try{
      await enableAudio();
      audioBtn.textContent = "声音已启用";
      audioBtn.disabled = true;
      statusEl.textContent = "声音已启用，开始弹奏";
      statusEl.style.color = "#00ff99";
    }catch(e){
      statusEl.textContent = "启用声音失败（请再点一次）";
      statusEl.style.color = "#ff6b6b";
    }
  });

  resetBtn.addEventListener("click", ()=> reset("已重置"));

  // 初始
  reset("未开始");
})();
</script>
</body>
</html>
